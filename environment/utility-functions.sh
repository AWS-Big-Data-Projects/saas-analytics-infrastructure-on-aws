#!/usr/bin/env bash

# Utility functions that can be reused by "sourcing" them into other scripts.
# Can be run from command line if you pass the function name and its arguments
# as parameters to this script.

# Returns framework environment variable names. These are variables
# needed by the variable resolution framework and do not contain
# any application-specific variables that are not part of the core
# framework
get_framework_env_var_names () {
    # this line of code is generated by a wizard and should not
    # be modified
    echo "APP_NAME AWS_ACCOUNT_ID AWS_DEFAULT_REGION ENABLE_ONCE_PER_ACCOUNT_RESOURCES ENV_NAME REMOTE_ENV_VAR_LOC CREATED_BY AWS_PRIMARY_REGION AWS_SECONDARY_REGION TF_S3_BACKEND_NAME SONAR_HOST_URL SONAR_PROJECT_KEY SONAR_TOKEN AWS_CREDS_TARGET_ROLE"
}

# Logs message and exits with error if the AWS CLI principal's account
# does not match the AWS account number for the application environment.
validate_aws_cli_account () {

    if [[ "$IS_VALID_CLI_ACCOUNT_ID" == "y" ]]; then
        return 0
    fi

    echo ""
    echo "Validating the AWS CLI logged in principal..."

    if [[ -z "$AWS_ACCOUNT_ID" ]] || [[ -z "$AWS_DEFAULT_REGION" ]]; then
        echo "" >&2
        echo -e "${RED} ERROR: environment values are not set in the current shell.${NC}" >&2
        echo "To fix this, execute your command from environment/Makefile," >&2
        echo "which automatically sets environment values, OR export your" >&2
        echo "current environment's values into the shell by running" >&2
        echo "this command in a BASH shell:" >&2
        echo "" >&2
        echo "source environment/utility-functions.sh export_local_app_env_vars" >&2
        echo "" >&2
        exit 1
    fi

    local cliAccountId=$(aws sts get-caller-identity | jq -r '.Account | select(type == "string")')
    
    if [[ "$AWS_ACCOUNT_ID" != "$cliAccountId" ]]; then
        echo "" >&2
        echo -e "${RED}ERROR: The AWS CLI must be logged in as a principal in the" >&2
        echo -e "       \"$AWS_ACCOUNT_ID\" account before proceeding.${NC}" >&2
        echo "Currently logged into account \"$cliAccountId\"." >&2
        echo "" >&2
        exit 1
    else
        echo "SUCCESS"

        # Cache value in memory so we don't keep checking over and over
        IS_VALID_CLI_ACCOUNT_ID="y"
    fi
}

# Deletes lines in a file between a start marker line and an end marker line.
# usage: delete_file_content_range "myFile.txt" "START_HERE" "END_HERE"
# param1: the path to the file
# param2: the pattern to match for the first line to delete
# param3: the pattern to match for the last line to delete
delete_file_content_range () {
    local filePath=$1
    local startMarker=$2
    local endMarker=$3

    if [[ -z "$filePath" ]] || [[ -z "$startMarker" ]] || [[ -z "$endMarker" ]]; then
        echo -e "${RED} ERROR: delete_file_content_range - invalid input params${NC}" >&2
        echo "usage: delete_file_content_range \"<filePath>\" \"<startMarker>\" \"<endMarker>\"" >&2
        return 1
    fi

    if [[ ! -f "$filePath" ]]; then
        echo -e "${RED} ERROR: delete_file_content_range - file \"$filePath\" does not exist.${NC}" >&2
        return 1
    fi

    local startLine=$(sed -n "/$startMarker/=" "$filePath")
    if [[ -z "$startLine" ]]; then
        echo -e "${RED} ERROR: delete_file_content_range did not find starting marker \"$startMarker\" in \"$filePath\"${NC}" >&2
        return 1
    fi

    local endLine=$(sed -n "/$endMarker/=" "$filePath")
    if [[ -z "$endLine" ]]; then
        echo -e "${RED} ERROR: delete_file_content_range did not find ending marker \"$endMarker\" in \"$filePath\"${NC}" >&2
        return 1
    fi

    local newContents
    if newContents=$(sed "${startLine},${endLine}d" "$filePath"); then
        echo "$newContents" > "$filePath"
    else
        echo -e "${RED} ERROR: delete_file_content_range \""$filePath"\" \"$startMarker\" \"$endMarker\" failed${NC}" >&2
        return 1
    fi
}

# Deletes lines in a file that match a pattern.
# usage: delete_file_matching_lines "myFile.txt" "something"
# param1: the path to the file
# param2: the pattern to match
delete_file_matching_lines () {
    local filePath=$1
    local match=$2

    if [[ -z "$filePath" ]] || [[ -z "$match" ]]; then
        echo -e "${RED} ERROR: delete_file_matching_lines - invalid input params${NC}" >&2
        echo "usage: delete_file_matching_lines \"<filePath>\" \"<match>\"" >&2
        return 1
    fi

    if [[ ! -f "$filePath" ]]; then
        echo -e "${RED} ERROR: delete_file_matching_lines - file \"$filePath\" does not exist.${NC}" >&2
        return 1
    fi

    local newContents
    if newContents=$(sed "/$match/d" $filePath); then
        echo "$newContents" > "$filePath"
    else
        echo -e "${RED} ERROR: delete_file_matching_lines \""$filePath"\" \"$match\" failed${NC}" >&2
        return 1
    fi
}

# Lists the files in this project that contain environment placeholders
# param1: optional - the directory to start the search from. Defaults to
#         the application root directory
get_template_files () {
    if [[ -z "$1" ]]; then
        local scriptDir=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )
        cd $scriptDir/..
    else
        cd $1
    fi
    
    echo $(grep -l -R --exclude-dir=environment --exclude-dir=.terraform --exclude-dir=node_modules '###[^#]\{1,50\}###' .)
}

# Sets global environment variables into the shell so that this script
# knows where to find project directories
set_project_locations () {
    local scriptDir=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )
    # if [[ ! -f $scriptDir/app-constants.json ]]; then
    #     return 0
    # fi
    # local appConstants=$(cat $scriptDir/app-constants.json)
    # const1=$(echo "$appConstants" | jq -r '.const1')

    projectDir=$scriptDir/..
    projectEnvDir="$scriptDir"
    projectIacDir="${projectDir}/iac"
    projectCicdDir="${projectDir}/cicd"
    projectBuildScriptDir="${projectDir}/build-script"
}

# Add global constants to print console output in different colors
set_colors () {
    CYAN='\033[0;36m'
    GRAY='\033[0;37m'
    GREEN='\033[0;32m'
    NC='\033[0m' # No Color
    PURPLE='\033[0;35m'
    RED='\033[0;31m'
    YELLOW='\033[1;33m'
}

# Asks a question with a default answer and will not return the 
# answer until it matches the supplied regex
# param1: the name of the variable to set using the Bash nameref feature
# param2: the question to ask
# param3: the default answer to the question
# param4: the regex pattern to match
# param5: the error message to show if the pattern does not match
get_answer () {
    local -n answer=$1
    local question=$2
    local defaultAnswer=$3
    local pattern=$4
    local msg=$5
    local defaultOptionString
    [ -z "$defaultAnswer" ] && defaultOptionString="" || defaultOptionString="[$defaultAnswer] "

    while true
    do
        read -p "$question $defaultOptionString" answer
        answer="${answer:=$defaultAnswer}"
        # echo "Answer was \"$answer\"" >&2   # This is useful for debugging
        [[ $answer =~ $pattern ]] && return 0
        echo $msg >&2
    done
}

# Asks a true or false question with a default answer and will not return the 
# answer until it is either "true" or "false"
# param1: the name of the variable to set using the Bash nameref feature
# param2: the question to ask
# param3: the default answer to the question 
true_or_false () {
    local -n tfAnswer=$1
    local question=$2
    local defaultAnswer=$3
    local pattern="^(true|false)$"
    local msg="answer must be true or false"
    question="${question} (true/false)?"

    get_answer tfAnswer "$question" "$defaultAnswer" "$pattern" "$msg"
}

# Validate that a value is "true" or "false". Log error and return error
# exit code if not.
# param1: variable name
# param2: variable value
validate_true_or_false () {

    if [[ -z "$1" ]]; then 
        echo -e "${RED} ERROR: validate_true_or_false - first parameter cannot be empty${NC}" >&2
        exit 1
    fi

    if [[ -z "$2" ]]; then 
        echo -e "${RED} ERROR: validate_true_or_false - value of \"$1\" cannot be empty${NC}" >&2
        exit 1
    fi

    local pattern="^(true|false)$"
    [[ $2 =~ $pattern ]] && return 0

    echo -e "${RED} ERROR: \"$1\" must be \"true\" or \"false\" but was \"$2\"${NC}" >&2
    exit 1
}

# Asks a yes or no question with a default answer and will not return the 
# answer until it is either y or n
# param1: the name of the variable to set using the Bash nameref feature
# param2: the question to ask
# param3: the default answer to the question 
yes_or_no () {
    local -n ynAnswer=$1
    local question=$2
    local defaultAnswer=$3
    local pattern="^[yn]$"
    local msg="answer must be y or n"
    question="${question} (y/n)?"

    get_answer ynAnswer "$question" "$defaultAnswer" "$pattern" "$msg"
}

# Validate that a value is "y" or "n". Log error and return error
# exit code if not.
# param1: variable name
# param2: variable value
validate_yes_or_no () {

    if [[ -z "$1" ]]; then 
        echo -e "${RED} ERROR: validate_yes_or_no - first parameter cannot be empty${NC}" >&2
        exit 1
    fi

    if [[ -z "$2" ]]; then 
        echo -e "${RED} ERROR: validate_yes_or_no - value of \"$1\" cannot be empty${NC}" >&2
        exit 1
    fi

    local pattern="^[yn]$"
    [[ $2 =~ $pattern ]] && return 0

    echo -e "${RED} ERROR: \"$1\" must be \"y\" or \"n\" but was \"$2\"${NC}" >&2
    exit 1
}

# Asks a question with a default answer and will not return the 
# answer until a valid number of characters is entered
# param1: the name of the variable to set using the Bash nameref feature
# param2: the question to ask
# param3: the default answer to the question 
# param4: the minimum valid answer length
# param5: the maximum valid answer length
# param6: optional. if set to "allowWhitespace", it will accept an answer
#         from the user that contains whitespace
length_range () {
    local -n rangeAnswer=$1
    local question=$2
    local defaultAnswer=$3
    local minLength=$4
    local maxLength=$5
    if [[ "$6" == "allowWhitespace" ]];
    then
        local pattern="^.{${minLength},${maxLength}}$"
    else
        local pattern="^[^[:space:]]{${minLength},${maxLength}}$"
    fi
    
    local msg="answer must be at least $minLength character(s) and no more than $maxLength. No whitespaces allowed."
    question="${question}"
    get_answer rangeAnswer "$question" "$defaultAnswer" "$pattern" "$msg"
}

# Asks a question and will not return until the answer is a valid AWS
# account number
# param1: the name of the variable to set using the Bash nameref feature
# param2: the question to ask
# param3: the default answer to the question 
aws_account_number () {
    local -n accountAnswer=$1
    local question=$2
    local defaultAnswer=$3
    local pattern="^[0-9]{12}$"
    local msg="Value must be a 12 digit number"

    get_answer accountAnswer "$question" "$defaultAnswer" "$pattern" "$msg"    
}

# Read input from a terminal and do not print what the user is typing
# param1: Bash nameref for the variable that will be set to the user's input
read_secret () {
    local -n readValue=$1

    # Disable echo.
    stty -echo

    # Read secret.
    read readValue

    # Enable echo.
    stty echo

    # Print a newline because the newline entered by the user after
    # entering the passcode is not echoed. This ensures that the
    # next line of output begins at a new line.
    echo
}

# Custom `select` implementation with support for a default choice
# that the user can make by pressing just ENTER.
# Pass the choices as the first argument with | delimited values ; e.g. 'Yes|No'
# The first choice is the default choice, unless you designate
# one of the choices as the default by passing the default value as the third parameter
# The default choice is printed with a trailing ' [default]'
# Pass the choice values as the second argument with | delimited values ; e.g. 'YES|NO'
# Output is the value of the selected choice
# Example:
#    choice=$(select_with_default 'Yes|No|Abort' 'One|Two|Three' 'Two')
select_with_default () {

    local options
    local values

    IFS='|' read -r -a options <<< "$1"
    IFS='|' read -r -a values <<< "$2"

    local numItems=${#options[@]}
    local item itemIndex i=0 defaultIndex=1

    if [[ ! -z "$3" ]];
    then
        local dli
        for dli in "${!values[@]}";
        do
            if [[ "${values[$dli]}" = "$3" ]];
            then
                defaultIndex=$(($dli + 1))
                break
            fi
        done
    fi

    zeroBasedDefaultIndex=$(($defaultIndex - 1))

    # allow for printing text in yellow
    local py=$(tput setaf 3)
    local pnormal=$(tput sgr0)
    
    # Print numbered menu items, based on the arguments passed.
    for itemIndex in ${!options[@]}; do
        item=${options[$itemIndex]}
        [[ "$itemIndex" == "$zeroBasedDefaultIndex" ]] && item="${item} ${py}[default]${pnormal}"
        printf '%s\n' "$((++i))) $item"
    done >&2 # Print to stderr, as `select` does.

    # Prompt the user for the index of the desired item.
    while :; do
        printf %s "${PS3-#? }" >&2 # Print the prompt string to stderr, as `select` does.
        read -r index
        # Make sure that the input is either empty or that a valid index was entered.
        [[ -z $index ]] && index=$defaultIndex && break  # empty input == default choice  
        (( index >= 1 && index <= numItems )) 2>/dev/null || { echo "Invalid selection. Please try again." >&2; continue; }
        break
    done

    # Output the selected choice.
    zeroChoiceIndex=$(($index - 1))
    printf ${values[$zeroChoiceIndex]}

}

validate_bash_version () {
    local requiredMajorVersion=5
    if [[ "${BASH_VERSINFO:-0}" -lt "$requiredMajorVersion" ]];
    then
        echo You currently have Bash version ${BASH_VERSINFO:-0}. Please upgrade to $requiredMajorVersion or later >&2
        exit 1
    fi
}

# Accepts a Bash nameref variable. If it has a blank value, the user
# will be prompted to enter a GitLab personal access token value and
# the user's input will be set as the nameref variable's value
ask_gitlab_token () {
    local -n gitLabTokenRef=$1

    if [[ ! -z "$HEADLESS" ]]; then
        # Headless mode expects that the GitLab personal access token
        # has been set into a "gltoken" environment variable
        gitLabTokenRef="$gltoken"

    else
        if [[ -z "$gitLabTokenRef" ]]; then
            echo ""
            echo "For security purposes, the text you type next will not be shown in the terminal."
            echo "Enter your GitLab access token or press \"return\" to skip: "
            read_secret gitLabTokenRef
        fi

        # support passing in the token via a "gltoken" value, which will read the
        # value of the "gltoken" environment variable so that users do not need
        # to type the token in plain text 
        if [[ "$gitLabTokenRef" == "gltoken" ]]; then
            gitLabTokenRef="$gltoken"
        fi

    fi

}

# Accepts a Bash nameref variable. If it has a blank value, the user
# will be prompted to enter a SonarQube user token value and
# the user's input will be set as the nameref variable's value
# param1: Bash nameref variable to set
ask_sonarqube_user_token () {
    local -n sonarTokenRef=$1

    if [[ ! -z "$HEADLESS" ]]; then
        # Headless mode expects that the SonarQube user token
        # has been set into a "sqtoken" environment variable
        sonarTokenRef="$sqtoken"

    else
        if [[ -z "$sonarTokenRef" ]]; then
            echo ""
            echo "For security purposes, the text you type next will not be shown in the terminal."
            echo "If you do not have a SonarQube user token, you can create one by opening a browser"
            echo "tab to ${SONAR_HOST_URL}/account/security"

            echo "Enter your SonarQube user token or press \"return\" to skip: "
            read_secret sonarTokenRef
        fi

        # support passing in the token via a "sqtoken" value, which will read the
        # value of the "sqtoken" environment variable so that users do not need
        # to type the token in plain text 
        if [[ "$sonarTokenRef" == "sqtoken" ]]; then
            sonarTokenRef="$sqtoken"
        fi

    fi

}

confirm_gitlab_repo_exists () {
    local repoCheckResponseCode=$(curl -L --write-out '%{http_code}' --silent --output /dev/null \
    --request GET --header "PRIVATE-TOKEN: ${gitLabToken}" \
    "$gitLabProjectsApiUrl")

    if [[ "$repoCheckResponseCode" != "200" ]]; then
        echo -e "${RED} ERROR: $gitProjectGroup/$gitProjectName does not appear to be a valid GitLab project${NC}" >&2
        return 1
    fi
}

# Returns the path of the file where the current environment setting is stored
get_current_env_file_path () {
    local scriptDir=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )
    echo "$scriptDir/.current-environment"
}

# Gets the current local environment
get_current_env () {

    if [[ "$CI" == "true" ]] || [[ "$CPA_NO_ENV_FILE" == "true" ]] || [[ "$CREATE_APP" == "true" ]]; then
        echo $ENV_NAME
    else
        local curEnvFilePath=$(get_current_env_file_path)
        if [[ ! -f "$curEnvFilePath" ]]; then
            echo "No current local environment is configured. \"$curEnvFilePath\" does not exist." >&2
            exit 1
        fi

        head -n 1 $curEnvFilePath
    fi
}

# Sets the current local environment to the first argument supplied
# and updates all the application environment variable values in memory
# for the shell to use the new environment's values
# param1: the environment to set as current
set_current_env () {
    local envToSet=$1
    local curEnvFilePath=$(get_current_env_file_path)
    echo "$envToSet" > $curEnvFilePath
    if [[ ! -z "$envToSet" ]] && [[ "setme" != "$envToSet" ]]; then
        export_local_app_env_vars 
    fi
}

# Returns "y" or "n"
does_current_env_setting_exist () {
    local curEnvFilePath=$(get_current_env_file_path)
    if [[ -f "$curEnvFilePath" ]]; then
        echo "y"
    else 
        echo "n"
    fi
}

# Looks for "environment name to AWS CLI profile mapping" file at
# environment/.cli-profiles.json. If this file exits, sets the 
# "AWS_PROFILE" environment variable to the profile that is set for 
# the current environment. If the current environment is not configured
# in .cli-profiles.json, looks to see if a "default" profile is set for
# all unmapped environments. The AWS CLI will use the value of 
# the "AWS_PROFILE" to know what AWS Account to communicate with.
# Example .cli-profiles.json
# {
#    "default": "default"
#    "qa":  "qa"
# }
set_aws_cli_profile () {
    local scriptDir=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )
    local profileJsonFile="$scriptDir/.cli-profiles.json"
    if [[ -f "$profileJsonFile" ]]; then
        local currentEnv=$(get_current_env)
        local cliProfile=$(cat $profileJsonFile | jq -r --arg currentEnv "$currentEnv" '.[$currentEnv] | select(type == "string")')

        if [[ -z "$cliProfile" ]]; then
            cliProfile=$(cat $profileJsonFile | jq -r '.default | select(type == "string")')
        fi

        if [[ ! -z "$cliProfile" ]]; then
            echo ""
            echo "Setting AWS_PROFILE to \"$cliProfile\" based on .cli-profiles.json"
            export AWS_PROFILE="$cliProfile"
        fi
    fi
}

# Creates an empty local environment file with the supplied envirnment name
# param1: the environment name
create_env_var_file () {
    local scriptDir=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )
    echo "{}" > $scriptDir/.environment-$1.json
}

# Deletes a local environment file with the supplied envirnment name
# No warning or confirmation is provided before the delete
# param1: the environment name
delete_env_var_file () {
    local scriptDir=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )
    rm $scriptDir/.environment-$1.json
}

# Return "y" if a local environment file already exists or "n" if not
# param1: the environment name
does_env_var_file_exist () {
    local scriptDir=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )
    if [[ -f "$scriptDir/.environment-$1.json" ]]; then
        echo "y"
    else
        echo "n"
    fi
}

# Detects the current environment to see which environment should be used
# and then returns the name of the file that holds the variable values
# for that environment
get_env_var_file_name () {
    local scriptDir=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )
    curEnvSettingExists=$(does_current_env_setting_exist)
    local setMe="setme"

    if [[ "$curEnvSettingExists" == "n" ]]; then
        set_current_env "$setMe"
    fi
    
    local currentEnv=$(get_current_env)
    if [[ "$currentEnv" == "$setMe" ]] || [[ -z "$currentEnv" ]]; then

        local showWarning="y"
        if [[ -z "$COMMAND_RUNNER_CONTEXT" ]] || [[ "$COMMAND_RUNNER_CONTEXT" =~ ^(create-environment|ce|switch-current-environment|sce|pull-env-vars|util)$ ]]; then
            showWarning="n"
        fi

        if [[ "$showWarning" == "y" ]]; then
            local curEnvFilePath=$(get_current_env_file_path)
            echo "" >&2
            echo -e "${YELLOW}WARNING: The current environment setting is not configured.${NC}" >&2
            echo "This is expected if you just downloaded your application's source code." >&2
            echo "" >&2
            echo "The current environment setting can be configured using one of these:" >&2
            echo "  * run \"make ce\" to start the Create New Application Environment Wizard if" >&2
            echo "    you haven't set up an environment yet. " >&2
            echo "  * run \"make sce\" to switch to an existing environment" >&2
            echo "  * run \"make pull-env-vars\" to download an environment" >&2
            echo "    from a remote source" >&2
            echo "  * directly set an existing environment as current by typing its" >&2
            echo "    name into \"$curEnvFilePath\"." >&2
            echo "" >&2
        fi
        
    fi

    echo $scriptDir/.environment-$currentEnv.json
}

# Sets the names of application environment variables as a list. Uses bash shell nameref feature.
# param1: the name of a variable in the calling script that should be set with the list
get_env_var_names () {
    validate_bash_version || exit 1

    local scriptDir=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )
    local requiredEnvVars
    IFS=$'\n' read -d '' -r -a requiredEnvVars < $scriptDir/app-env-var-names.txt
    local -n envVarKeys=$1
    envVarKeys=("${OPT_IN_ENV_VAR_KEYS[@]}")
    local varIndex
    
    # Create list of environment variable names
    for varIndex in ${!requiredEnvVars[@]}; do
        local varName=${requiredEnvVars[$varIndex]}
        
        # ignore any line that begins with -- or #
        [[ "$varName" =~ ^--.*|^#.*|^\/.* ]] && continue
        
        # strip trailing whitespace and anything after that so that we
        # just get the variable name and remove any comments
        varName=${varName%[[:space:]]*}
        envVarKeys+=("$varName")
    done

    # try to set Git repo variables from remote origin setting
    if [[ -z "$CREATE_APP" ]]; then
        if [[ -z "$gitProjectName" ]]; then set_git_env_vars_from_remote_origin; fi
        if [[ ! -z "$gitProjectName" ]]; then envVarKeys+=("gitProjectName"); fi
        if [[ ! -z "$gitProjectGroup" ]]; then envVarKeys+=("gitProjectGroup"); fi
        if [[ ! -z "$gitRepoDomain" ]]; then envVarKeys+=("gitRepoDomain"); fi
    fi

}

# Retrieves the value of an environment variable.
# Throw an error if the variable does not have a value.
# param1: the name of the environment variable to retrieve the value for
get_env_var_value () {
    local scriptDir=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )
    local envVarName=$1
    [ -z "$envVarName" ] && echo -e "${RED} ERROR: environment variable name is required as the first argument to this script${NC}" >&2 \
    && echo "usage: get_env_var_value <myEnvVarName>" >&2 && exit 1
    
    local currentEnv=$(get_current_env)
    local envVarValue=${!envVarName}
    
    if [[ -z "$envVarValue" ]]; then
        echo -e "${RED} ERROR: \"$envVarName\" environment variable is not set in the " >&2
        echo "  \"$currentEnv\" environment. Set it to a value or \"blank\" if there" >&2
        echo -e "  is no value or remove it from \"app-env-var-names.txt\" if it is not needed.${NC}" >&2
        exit 1
    fi
        
    echo $envVarValue
}

# Exports (as environment variables) all values defined in the .environment.json
# file. If calling from command prompt directly, use the "source" keyword.
export_local_app_env_vars () {
    
    if ! command -v jq --version &> /dev/null
    then
        echo -e "${RED} ERROR: jq could not be found. Please install jq, then run this script again.${NC}" >&2
        exit 1
    fi
    
    local environmentJsonFile=$(get_env_var_file_name)

    # Useful for debugging
    # echo "Running export on $environmentJsonFile" >&2

    local envJsonContents=$(cat "$environmentJsonFile")
    if [[ "{}" != "$envJsonContents" ]]; then
        eval "export $(echo "$envJsonContents" \
        | jq -r 'to_entries | map("\(.key)=\(.value)") | @sh')"
    fi
}

# Exports (as environment variables) all values defined in the AWS SSM Parameter
# Store for the current environment (the value of $ENV_NAME)
# If calling from command prompt directly, use the "source" keyword.
export_env_vars_from_ssm () {

    local ssmEnvJson=$(aws ssm get-parameters-by-path \
    --region "$AWS_DEFAULT_REGION" \
    --max-items 200 \
    --path "/$APP_NAME/remoteVars/$ENV_NAME/" \
    --with-decryption \
    --query "Parameters[].{key:Name,value:Value}")

    $(echo $ssmEnvJson | \
    jq -r ". | map(\"export \" + (.key|ltrimstr(\"/$APP_NAME/remoteVars/$ENV_NAME/\")) + \"=\" + .value + \"\")[]")
}

pull_env_vars () {
    local remoteLocNames="AWS SSM Parameter Store|GitLab (requires Maintainer privileges)"
    local remoteLocVals="ssm|gitlab"
    echo "Which remote environment do you want to import from?"
    local importFrom=$(select_with_default "$remoteLocNames" "$remoteLocVals" "ssm")
    local remoteEnvNames

    if [[ "$importFrom" == "ssm" ]]; then
        remoteEnvNames=$(echo $(get_ssm_environment_names))
    elif [[ "$importFrom" == "gitlab" ]]; then
        local gitLabToken
        ask_gitlab_token gitLabToken
        local remoteEnvNames
        get_gitlab_environment_names remoteEnvNames $gitLabToken
    fi

    if [[ -z "$remoteEnvNames" ]] || [[ "$remoteEnvNames"  == "[]" ]];
    then
        echo "No remote environments found"
        return 0
    fi

    remoteEnvNames=$(echo $remoteEnvNames | sed -e 's/ /|/g')

    echo "Which environment do you want to import?"
    local importEnv=$(select_with_default "$remoteEnvNames" "$remoteEnvNames" "")
    local envFileExisted=$(does_env_var_file_exist $importEnv)

    # Backup current environment and set the environment to import as the current environment
    local backupEnvName=$ENV_NAME
    ENV_NAME=$importEnv
    
    if [[ "$envFileExisted" == "n" ]]; then
        create_env_var_file "$importEnv"
    fi
    
    set_current_env $importEnv

    if [[ "$importFrom" == "ssm" ]]; then
        pull_env_vars_from_ssm_to_local_json
    elif [[ "$importFrom" == "gitlab" ]]; then
        pull_env_vars_from_gitlab_to_local_json $gitLabToken || exit 1
    fi

    local environmentJsonFile=$(get_env_var_file_name)
    if [[ -f "$environmentJsonFile" ]]; then
        echo "Successfully imported \"$importEnv\" environment!"
    else
        ENV_NAME=$backupEnvName
        set_current_env $ENV_NAME
        if [[ "$envFileExisted" == "n" ]]; then
            delete_env_var_file "$importEnv"
        fi
        echo -e "${RED} ERROR: \"$importEnv\" environment could not be imported.${NC}" >&2
        exit 1
    fi
    
}

# This function reads the file that is supplied as the first function argument.
# It then resolves all placeholder values found in that file by
# replacing the ###ENV_VAR_NAME### placeholder with the value of the ENV_VAR_NAME.
# Finally, it sets a nameref variable to the file contents with all variables resolved.
# param1: the name of the file that has placeholders to resolve
# param2: the name of the variable to set using the Bash nameref feature
resolve_placeholders () {

    local filePath=$1
    local -n outputVar=$2
    if [[ -z "$filePath" ]]; then
        echo "The first argument to resolve_placeholders must be the path of the file to resolve" >&2
        exit 1
    fi

    local envVarNames
    get_env_var_names envVarNames || exit 1
    
    local SED_PATTERNS=""
    local i
    
    # Build a SED expression that will search and replace all placeholder values found
    # that match the application environment variables
    for i in ${!envVarNames[@]}; do
        local varName=${envVarNames[$i]}
        if [[ ! -z "${LOOKUPS[$varName]}" ]]; then

            if [[ "$DYNAMIC_RESOLUTION" != "y" ]]; then
                envVarValue="blank"
            else
                # Check for cached value
                local envVarValue=$(echo $LOOKUP_VALS_JSON | jq -r --arg placeholder "$varName" '.[$placeholder] | select(type == "string")')

                if [[ ! -z "$envVarValue" ]]; then
                    :
                elif [[ "$varName" == SSM_* ]]; then
                    echo ""
                    echo "Looking up \"${LOOKUPS[$varName]}\" from region $AWS_DEFAULT_REGION"
                    echo ""
                    local envVarValue=$(aws ssm --region $AWS_DEFAULT_REGION get-parameter --name ${LOOKUPS[$varName]} --with-decryption --query Parameter.Value --output text)

                    if [[ -z "$envVarValue" ]]; then
                        if [[ -z "$FAIL_ON_LOOKUP_ERROR" ]]; then
                            echo "ERROR: SSM lookup of \"${LOOKUPS[$varName]}\" from region $AWS_DEFAULT_REGION failed or returned an empty value." >&2
                            exit 1
                        else
                            echo "WARNING: SSM lookup of \"${LOOKUPS[$varName]}\" from region $AWS_DEFAULT_REGION failed or returned an empty value." >&2
                            echo "Value will be defaulted to a blank string" >&2
                            envVarValue="blank"
                        fi 
                    fi

                    # Add looked up value to in-memory cache
                    LOOKUP_VALS_JSON=$(echo "$LOOKUP_VALS_JSON" | jq --arg key "$varName" --arg val "$envVarValue" '. + {($key): $val}')
                
                else
                    echo "ERROR: $varName lookup cannot be completed." >&2
                    echo "If it is an SSM parameter, rename it to SSM_{$varName}." >&2
                    exit 1
                fi
                
            fi

        else
            # check that the env var value can be retrieved or exit if not
            get_env_var_value $varName 1> /dev/null || exit 1
            local envVarValue=$(get_env_var_value $varName)
        fi
        
        if [[ "$envVarValue" == "blank" ]]; then
            envVarValue=""
        fi
        
        SED_PATTERNS="${SED_PATTERNS}s|###$varName###|$envVarValue|g;"
    done

    # Add support for replacing CUR_DIR_NAME, which is the name of the
    # directory (without path) that the file resides in
    local dirName=$(dirname $filePath)
    dirName=${dirName%/.}        # strip path ending with /. if it exists
    dirName=${dirName##*/}       # just get directory name without path
    dirName=${dirName:-/}        # to correct for the case where dir=/
    SED_PATTERNS="${SED_PATTERNS}s|###CUR_DIR_NAME###|$dirName|g;"

    local command=$(echo "cat $filePath | sed '$SED_PATTERNS'")
    local resolvedContent="$(eval $command)"

    if [[ $resolvedContent =~ ^.*(###.*###) ]]; then
        echo -e "${RED}ERROR: $filePath contains unresolved placeholder: ${BASH_REMATCH[1]}${NC}" >&2

        if [[ "${BASH_REMATCH[1]}" == "###git"* ]]; then
            echo "Placeholder names that start with \"git\" are set based upon the local Git" >&2
            echo "repo settings. Please ensure that this project is set up in a Git repo and" >&2
            echo "that \"git remote -v\" returns a value. If you do not want to set up the Git" >&2
            echo "CLI repo settings locally, you can set the git* placeholder values by exporting" >&2
            echo "them as environment variables in your shell. Do not use app-env-var-names.txt" >&2
            echo "to configure git* variables." >&2
        else
            echo "This could be because the placeholder expression has a typo or" >&2
            echo "because the placeholder is not defined in app-env-var-names.txt" >&2
        fi

        exit 1
    fi

    outputVar="$resolvedContent"
}

# Resolve placeholders in a file and print the result to the console
# param1: the name of the file that has placeholders to resolve
print_resolved_placeholders () {
    local filePath=$1
    local resolved
    resolve_placeholders "$filePath" resolved
    echo "$resolved"
}

# Resolves placeholders in all application template files.
# WARNING - this will leave the files in a changed state, which could cause
#           them to accidentally get committed to version control without 
#           the placeholders
# param1: optional - the resolution mode. Defaults to overwriting template files.
#         If you provide a value of "dryRun" then the template files will be resolved 
#         but their contents on disk will not be overwritten
#         If you provide a value of "backup" then the template files will be resolved 
#         but a backup will be taken first so that the original file can be restored
# param2: optional - the directory to look for templates. Defaults to the application
#         root directory
resolve_template_files () {
    local replaceMode=$1
    local templateRootDir=$2
    local scriptDir=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )
    local templatesArray=($(get_template_files "$templateRootDir"))
    local failureCount=0
    local successCount=0
    local failedFiles
    local mode
    
    if [[ -z "$replaceMode" ]]; then
        mode="OVERWRITE_FILES"
    elif [[ "dryrun" == "${replaceMode,,}" ]]; then # case-insensitive string comparison
        mode="DRY_RUN"
    elif [[ "backup" == "${replaceMode,,}" ]]; then # case-insensitive string comparison
        mode="BACKUP"
    else
        echo -e "${RED}ERROR: invalid value of \"$replaceMode\" supplied to resolve_template_files function.${NC}" >&2
        echo "Valid values are \"\", \"dryRun\", and \"backup\" ." >&2
        exit 1
    fi

    if [[ -z "$templateRootDir" ]]; then
        templateRootDir="$scriptDir/.."
    fi

    echo ""
    echo "Resolving templates in $templateRootDir"

    local i
    for i in ${!templatesArray[@]}; do
        local fileName=${templatesArray[$i]}

        if [[ "$fileName" == *"$BACKUP_SUFFIX" ]]; then
            continue
        fi

        if [[ "$fileName" == *".zip" ]]; then
            continue
        fi

        echo ""
        echo "Resolving $templateRootDir/$fileName"

        local resolved
        if [[ "$mode" == "BACKUP" ]]; then
            backup_then_resolve $templateRootDir $fileName
            if [ $? -eq 0 ]; then
                successCount=$((successCount+1))
            else
                failureCount=$((failureCount+1))
                failedFiles="${failedFiles}      $templateRootDir/$fileName\n\n"
            fi
        else
            local resolved
            resolve_placeholders "$templateRootDir/$fileName" resolved
            if [ $? -eq 0 ]; then
                successCount=$((successCount+1))

                # check for "dry run" mode and overwrite file if not
                if [[ "$mode" != "DRY_RUN" ]]; then
                    echo "$resolved" > $templateRootDir/$fileName
                fi
            else
                failureCount=$((failureCount+1))
                failedFiles="${failedFiles}      $templateRootDir/$fileName\n\n"
            fi
        fi

    done

    if [[ ${#LOOKUPS[@]} -gt 0 ]] && [[ "$DYNAMIC_RESOLUTION" != "y" ]]; then
        echo ""
        echo "WARNING: dynamic variable resolution is disabled."
        echo "All dynamic variables will be set to an empty string."
        echo "You can enable dynamic variable resolution by setting"
        echo "the \"DYNAMIC_RESOLUTION\" environment variable to \"y\""
        echo ""
    fi

    echo ""
    echo "Template Resolution Result Summary"
    echo "   MODE:    $mode"
    echo "   SUCCESS: $successCount"

    if [[ "$failureCount" == "0" ]]; then
        echo "   FAILURE: $failureCount"
    else
        echo -e "   ${RED}FAILURE: ${failureCount}${NC}"
    fi
    
    if [[ ! -z "$failedFiles" ]]; then
        echo "   Failed Files:"
        echo -e "$failedFiles"
        return 1
    fi
}

# This function generates a file that can be imported by make. The imported
# file will define make variables for all application environment variables.
# param1: optional - the make target that will be executed
generate_make_env () {

    local substring="bash"
    local curShell=$(ps -p $$ | tail -n +2)

    if [[ ! "${curShell#*"$substring"}" != "$curShell" ]]; then
        echo -e "${RED}ERROR: The shell must be bash version 5 or greater but was \"$curShell\".${NC}" >&2
        exit 1
    fi

    if ! command -v jq --version &> /dev/null
    then
        echo -e "${RED}ERROR: jq could not be found. Please install jq, then run this script again.${NC}" >&2
        exit 1
    fi

    if [[ ! -z "$1" ]]; then 
        COMMAND_RUNNER_CONTEXT="$1"
        COMMAND_RUNNER_CONTEXT="${COMMAND_RUNNER_CONTEXT#"generate_make_env "}"
    fi
    
    local environmentJsonFile=$(get_env_var_file_name)

    if [[ -f "$environmentJsonFile" ]]; then
        cat $environmentJsonFile | jq -r '. | to_entries | map("export " + .key + ":=" + .value)[]' > make-env

        if ! grep -q "gitProjectGroup" "make-env"; then
            set_git_env_vars_from_remote_origin
            if [[ ! -z "gitProjectGroup" ]]; then
                echo "export gitProjectGroup:=$gitProjectGroup" >> make-env
                echo "export gitProjectName:=$gitProjectName" >> make-env
                echo "export gitRepoDomain:=$gitRepoDomain" >> make-env
            fi
        fi

    else
        if [[ ! -z "$COMMAND_RUNNER_CONTEXT" ]] && [[ "$COMMAND_RUNNER_CONTEXT" != @(ce|create-environment|pull-env-vars) ]]; then
            echo -e "${YELLOW}WARNING: environment settings file \"$environmentJsonFile\" could not be found.${NC}" >&2
            echo "Please ensure that the current environment is set correctly in environment/.current-environment" >&2
            echo "" >&2
        fi
        echo "" > make-env
    fi
    
    # append variables to tell Make where the project is
    # local makeExports="export PROJECT_ROOT_DIR:=$projectDir"
    # makeExports="${makeExports}\nexport PROJECT_IAC_DIR:=$projectIacDir"
    # makeExports="${makeExports}\nexport PROJECT_CICD_DIR:=$projectCicdDir"
    # echo -e "$makeExports" >> make-env
}

# Outputs application environment variables that are
# available in the current shell as JSON.
app_env_vars_to_json () {
    
    if ! command -v jq --version &> /dev/null
    then
        echo -e "${RED}ERROR: jq could not be found. Please install jq, then run this script again.${NC}" >&2
        exit 1
    fi
    
    local scriptDir=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )
    
    local envVarKeyValuePairs=()
    local envVarNames
    get_env_var_names envVarNames || exit 1
    local i

    for i in ${!envVarNames[@]}; do
        local varName=${envVarNames[$i]}

        if [[ ! -z "${LOOKUPS[$varName]}" ]]; then 
            continue
        fi
        
        # check that the env var value can be retrieved or exit if not
        get_env_var_value $varName 1> /dev/null || exit 1
        local envVarValue=$(get_env_var_value $varName)
        
        envVarKeyValuePairs+=("${varName}=${envVarValue}")
    done
    
    # Print application environment variable key/value pairs in JSON format
    local joined
    printf -v joined '%s,' "${envVarKeyValuePairs[@]}"
    echo "${joined%,}" | jq -R 'split(",") | map(split("=")) | map({(.[0]): .[1]}) | add'
}

# Based on the required variables set in app-env-var-names.txt, 
# prints .environment JSON with blank values
print_blank_app_env_vars_json () {
    
    if ! command -v jq --version &> /dev/null
    then
        echo -e "${RED}ERROR: jq could not be found. Please install jq, then run this script again.${NC}" >&2
        exit 1
    fi
    
    local scriptDir=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )
    
    local envVarKeyValuePairs=()
    local envVarNames
    get_env_var_names envVarNames || exit 1
    local i
    
    for i in ${!envVarNames[@]}; do
        local varName=${envVarNames[$i]}
        
        if [[ "$varName" == "REMOTE_ENV_VAR_LOC" ]]; then
            local envVarValue="na"
        elif [[ ! -z "${LOOKUPS[$varName]}" ]]; then
            continue
        elif [[ "$varName" =~ ^(gitProjectName|gitProjectGroup|gitRepoDomain)$ ]]; then
            continue
        else
            local envVarValue="blank"
        fi
    
        envVarKeyValuePairs+=("${varName}=${envVarValue}")
    done
    
    # Print application environment variable key/value pairs in JSON format
    local joined
    printf -v joined '%s,' "${envVarKeyValuePairs[@]}"
    echo "${joined%,}" | jq -R 'split(",") | map(split("=")) | map({(.[0]): .[1]}) | add'
}

# Takes a backup of a file then runs resolve_placeholders on the file.
# Does nothing if file does not exist.
# param1: path to directory that contains the file to resolve
# param2: file name where file may contain placeholders to resolve
backup_then_resolve () {
    local directory=$1
    local orginalFileName=$2
    local copyFileName="${orginalFileName}${BACKUP_SUFFIX}"
    
    if [[ ! -f $directory/$orginalFileName ]]; then
        return 0
    fi
    
    local resolved
    resolve_placeholders "$directory/$orginalFileName" resolved
    if [[ -z "$resolved" ]];
    then
        exit 1
    else
        mv $directory/$orginalFileName $directory/$copyFileName
    fi
    
    echo "$resolved" > $directory/$orginalFileName
}

# Deletes a file and replaces it with its backup
# Does nothing if file does not exist.
# param1: path to directory that contains the file to restore
# param2: name of the file to restore
restore_backup () {
    local directory=$1
    local orginalFileName=$2
    local copyFileName="${orginalFileName}${BACKUP_SUFFIX}"

    if [[ -f "$directory/$copyFileName" ]]; then
        echo ""
        echo "Restoring $directory/$copyFileName"
    fi
    
    if [[ ! -f $directory/$copyFileName ]]; then
        return 0
    fi
    
    rm $directory/$orginalFileName
    mv $directory/$copyFileName $directory/$orginalFileName
}

# Deletes resolved files and replaces then with their original backups.
# param1: optional - the directory to look for templates. Defaults to the application
#         root directory
restore_template_files () {
    local templateRootDir=$1
    local scriptDir=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )
    local templatesArray=($(get_template_files "$templateRootDir"))

    if [[ -z "$templateRootDir" ]]; then
        templateRootDir="$scriptDir/.."
    fi

    echo ""
    echo "Restoring $templateRootDir templates from backup"

    local i
    for i in ${!templatesArray[@]}; do
        local fileName=${templatesArray[$i]}
        fileName=${fileName%"$BACKUP_SUFFIX"} # remove .bak suffix
        restore_backup $templateRootDir $fileName
    done

    echo ""
    echo "Template restoration from backup is complete"
}

# Resolves environment variable placeholders in template files in 
# the requested directory (after creating a backup copy of each template 
# file). Next, executes the supplied command from that directory
# and then restores the template files to their original state.
# param1: the path to the directory where the template files live
# param2: the command to execute against the directory (e.g. "cat myfile.txt")
exec_command_for_env () {
    local myTemplateDir=$1
    local myCommand=$2

    if [[ -z "$myTemplateDir" ]]; then
        echo -e "${RED} ERROR: exec_command_for_env - template directory input parameter is required.${NC}" >&2
        exit 1
    elif [[ ! -d "$myTemplateDir" ]]; then
        echo -e "${RED} ERROR: exec_command_for_env - template directory \"$myTemplateDir\" does not exist.${NC}" >&2
        exit 1
    elif [[ -z "$myCommand" ]]; then
        echo -e "${RED} ERROR: exec_command_for_env - command input parameter is required.${NC}" >&2
        exit 1
    fi
    
    echo ""
    echo -e "${CYAN}Executing \"$myCommand\" on $myTemplateDir${NC}"
    
    resolve_template_files "backup" "$myTemplateDir"
    cd $myTemplateDir
    eval "$myCommand"
    local commandExitCode=$?
    cd - &> /dev/null # Switch back to whatever the working directory was before

    restore_template_files $myTemplateDir

    echo ""
    echo -e "${CYAN}Finished executing \"$myCommand\" on $myTemplateDir${NC}"
    
    return $commandExitCode
}

# Resolves environment variable placeholders in files in the requested 
# root Terraform module directory and then executes Terraform for the 
# current Terraform mode (plan, appy, destroy)
# param1: the name of the module to run. Should be under iac/roots.
exec_tf_for_env () {
    if ! command -v terraform --version &> /dev/null
    then
        echo -e "${RED} ERROR: terraform could not be found. Please install terraform, then run this script again.${NC}" >&2
        exit 1
    fi

    if [[ -z "$TF_MODE" ]]; then
        TF_MODE="apply"
    fi
    
    local rootModulesParentDir=$projectIacDir/roots
    local rootModuleName=$1
    [ -z "$rootModuleName" ] && echo -e "${RED} ERROR: root module name is required as the first argument to the exec_tf_for_env function${NC}" >&2 \
    && exit 1
    
    local rootModuleDir=$rootModulesParentDir/$rootModuleName

    # Note, the ${*:2} below allows you to optionally supply arguments
    # to Terraform from the calling script
    local tfOptions=${*:2}
    local tfCommand=$(echo "terraform $TF_MODE ${tfOptions}" | xargs) # trim whitespace

    echo ""
    echo -e "${CYAN}Executing \"$tfCommand\" on $rootModuleDir${NC}"
    
    [ ! -d "$rootModuleDir" ] && echo -e "${RED} ERROR: Directory $rootModuleDir DOES NOT EXIST when executing the exec_tf_for_env function${NC}" >&2 && exit 1
    
    set_aws_cli_profile
    validate_aws_cli_account

    if [[ ! "$TF_MODE" =~ ^(plan|apply|destroy|validate|console)$ ]]; then
        echo -e "${RED} ERROR: invalid TF_MODE value \"$TF_MODE\". Must be one of: plan|apply|destroy|validate|console${NC}" >&2
        exit 1
    fi

    resolve_template_files "backup" "$rootModuleDir"

    if [ $? -eq 0 ]; then
        cd $rootModuleDir
        echo Terraform backend for root module $rootModuleName:
        echo $resolvedTf
        terraform init
        
        echo TF_MODE is $TF_MODE
        
        if [[ "$TF_MODE" == "apply" ]] || [[ "$TF_MODE" == "destroy" ]]; then
            terraform $TF_MODE -auto-approve $tfOptions
        else 
            terraform $TF_MODE $tfOptions
        fi

    fi

    local iacExitCode=$?

    if [[ "$ENABLE_ONCE_PER_ACCOUNT_RESOURCES" == "true" ]] && [[ "$TF_MODE" == "apply" ]] && [[ "$rootModuleName" == "cicd" ]] && [[ -f "$rootModulesParentDir/cicd/code-commit-mirror.tf" ]]; then 
        local tfCodeCommitSecretArn=$(terraform output)
        # get the value of the RepositoryCredsSecretArn output
        tfCodeCommitSecretArn=${tfCodeCommitSecretArn#*'"'}; tfCodeCommitSecretArn=${tfCodeCommitSecretArn%'"'*}
        if [[ -z "$tfCodeCommitSecretArn" ]]; then
            echo -e "${RED} ERROR: Failed to get ARN of secret that contains CodeCommit connection info.${NC}" >&2
            echo "Secret ARN should be in \"RepositoryCredsSecretArn\" output of the cicd Terraform module" >&2
        else
            register_push_mirror "$tfCodeCommitSecretArn"
        fi
    fi

    restore_template_files $rootModuleDir

    echo ""
    echo -e "${CYAN}Finished executing \"$tfCommand\" on $rootModuleDir${NC}"
    
    return $iacExitCode
}

# Resolves environment variable placeholders in the requested root CDK
# module files then executes CDK deployment
# param1: the name of the root module
exec_cdk_for_env () {

    if ! command -v cdk --version &> /dev/null
    then
        echo -e "${RED} ERROR: cdk could not be found. Please install cdk, then run this script again.${NC}" >&2
        exit 1
    fi

    if [[ -z "$CDK_MODE" ]]; then
        CDK_MODE="deploy"
    fi
    
    local rootModulesParentDir=$projectIacDir/roots
    local rootModuleName=$1
    [ -z "$rootModuleName" ] && echo -e "${RED} ERROR: root module name is required as the first argument to the exec_cdk_for_env function${NC}" >&2 \
    && exit 1
    
    local rootModuleDir=$rootModulesParentDir/$rootModuleName

    echo ""
    echo -e "${CYAN}Executing \"cdk $CDK_MODE\" on $rootModuleDir${NC}"

    [ ! -d "$rootModuleDir" ] && echo -e "${RED} ERROR: Directory $rootModuleDir DOES NOT EXIST when executing the exec_cdk_for_env function${NC}" >&2 && exit 1

    set_aws_cli_profile
    validate_aws_cli_account

    if [[ ! "$CDK_MODE" =~ ^(deploy|destroy|diff|synth)$ ]]; then
        echo -e "${RED} ERROR: invalid CDK_MODE value \"$CDK_MODE\". Must be \"deploy\" or \"destroy\" or \"diff\" or \"synth\"${NC}" >&2
        exit 1
    fi

    resolve_template_files "backup" "$rootModuleDir"

    # If you want to target a specifc stack name, use
    # "$APP_NAME-$ENV_NAME-$rootModuleName"

    local cdkDiff
    local projectCdk="$rootModuleDir/node_modules/aws-cdk/bin/cdk"

    if [ $? -eq 0 ]; then
        cd $rootModuleDir

        if [ "$CDK_MODE" == "destroy" ]; then
            echo ""
            echo "Executing \"$projectCdk destroy\""
            $projectCdk destroy -f
        else
            echo ""
            echo "Executing \"npm install\""
            npm install

            if [ "$CDK_MODE" == "synth" ]; then
                echo ""
                echo "Executing \"$projectCdk synth\""
                $projectCdk synth
            elif [ "$CDK_MODE" == "diff" ]; then
                echo ""
                echo "Executing \"$projectCdk diff\""
                $projectCdk diff
            else
                echo ""
                echo "Executing \"$projectCdk diff\""
                $projectCdk diff --fail && cdkDiff="n" || cdkDiff="y"

                if [[ "$cdkDiff" == "y" ]]; then
                    echo ""
                    echo "Executing \"$projectCdk deploy\""
                    $projectCdk deploy --require-approval never
                fi
            fi

        fi

    fi

    local iacExitCode=$?

    if [[ "$ENABLE_ONCE_PER_ACCOUNT_RESOURCES" == "true" ]] && [[ "$CDK_MODE" == "deploy" ]] && [[ "$rootModuleName" == "cicd" ]] && [[ -f "$rootModulesParentDir/cicd/src/constructs/codecommit-push-mirror-construct.ts" ]]; then 
        local stackName="$APP_NAME-$ENV_NAME-cicd"
        local cdkCodeCommitSecretArn
        get_mirror_secret_arn_from_cf_stack cdkCodeCommitSecretArn "$stackName"
        if [[ -z "$cdkCodeCommitSecretArn" ]]; then
            echo -e "${RED} ERROR: Failed to get ARN of secret that contains CodeCommit connection info.${NC}" >&2
            echo "Secret ARN should be in the output of the $stackName CDK stack. Output name should contain \"RepositoryCredsSecretArn\"." >&2
        else
            register_push_mirror "$cdkCodeCommitSecretArn"
        fi
    fi

    restore_template_files $rootModuleDir

    echo ""
    echo -e "${CYAN}Finished executing \"cdk $CDK_MODE\" on $rootModuleDir${NC}"

    return $iacExitCode
}

# Resolves environment variable placeholders in the requested root CloudFormation
# module files then executes "cloudformation deploy"
# param1: root module name
exec_cf_for_env () {
    
    local rootModulesParentDir=$projectIacDir/roots
    local rootModuleName=$1
    [ -z "$rootModuleName" ] && echo -e "${RED} ERROR: root module name is required as the first argument to the exec_cf_for_env function${NC}" >&2 \
    && exit 1
    
    local rootModuleDir=$rootModulesParentDir/$rootModuleName

    echo ""
    echo -e "${CYAN}Executing CloudFormation command(s) on $rootModuleDir${NC}"

    [ ! -d "$rootModuleDir" ] && echo -e "${RED} ERROR: Directory $rootModuleDir DOES NOT EXIST${NC}" >&2 && exit 1

    set_aws_cli_profile
    validate_aws_cli_account

    resolve_template_files "backup" "$rootModuleDir"

    if [ $? -eq 0 ]; then
        cd $rootModuleDir

        echo ""
        echo "Executing \"cloudformation deploy\""

        if [[ -f "parameters.json" ]]; then
            aws cloudformation deploy \
            --template-file $rootModuleName-cf.yml \
            --parameter-overrides file://parameters.json \
            --stack-name $APP_NAME-$ENV_NAME-$rootModuleName \
            --capabilities CAPABILITY_NAMED_IAM \
            --no-fail-on-empty-changeset \
            --tags App=$APP_NAME Env=$ENV_NAME
        else
            aws cloudformation deploy \
            --template-file $rootModuleName-cf.yml \
            --stack-name $APP_NAME-$ENV_NAME-$rootModuleName \
            --capabilities CAPABILITY_NAMED_IAM \
            --no-fail-on-empty-changeset \
            --tags App=$APP_NAME Env=$ENV_NAME
        fi
    fi

    local iacExitCode=$?

    restore_template_files $rootModuleDir

    echo ""
    echo -e "${CYAN}Finished executing CloudFormation command(s) on $rootModuleDir${NC}"

    return $iacExitCode
}

# Performs cloudformation destroy on the supplied root module
# param1: root module name
destroy_root_cf_stack_by_name () {
    local rootModulesParentDir=$projectIacDir/roots
    local rootModuleName=$1
    [ -z "$rootModuleName" ] && echo -e "${RED} ERROR: root module name is required as the first argument to the destroy_root_cf_stack_by_name function${NC}" >&2 \
    && exit 1
    
    local rootModuleDir=$rootModulesParentDir/$rootModuleName

    [ ! -d "$rootModuleDir" ] && echo -e "${RED} ERROR: Directory $rootModuleDir DOES NOT EXIST${NC}" >&2 && exit 1

    set_aws_cli_profile
    validate_aws_cli_account

    cd $rootModuleDir

    echo ""
    echo "Executing \"cloudformation delete-stack --stack-name $APP_NAME-$ENV_NAME-$rootModuleName\""

    aws cloudformation delete-stack \
	--stack-name $APP_NAME-$ENV_NAME-$rootModuleName

    aws cloudformation wait stack-delete-complete --stack-name $APP_NAME-$ENV_NAME-$rootModuleName
}

# Resolves environment variable placeholders in the CodeCommit push mirror
# CloudFormation template then executes "cloudformation deploy"
# param1: optional the AWS region to deploy to. Defaults to $AWS_DEFAULT_REGION
deploy_code_commit_push_mirror_cf_stack () {
    local cicdCodeCommitDir=$projectCicdDir/code-commit-mirror

    [ ! -d "$cicdCodeCommitDir" ] && echo -e "${RED} ERROR: Directory $cicdCodeCommitDir DOES NOT EXIST${NC}" >&2 && exit 1

    echo ""
    echo "Deploying CodeCommit push mirror CloudFormation stack..."

    set_aws_cli_profile
    validate_aws_cli_account

    resolve_template_files "backup" "$cicdCodeCommitDir"

    if [ $? -eq 0 ]; then
        cd $cicdCodeCommitDir

        local region=$1
        : ${region:=$AWS_DEFAULT_REGION} # set to default region if region was not passed as the first argument

        echo ""
        echo "Executing \"cloudformation deploy\" for region: \"$region\""

        local stackName="$APP_NAME-codecommit"

        if [[ -f "parameters.json" ]]; then
            aws cloudformation deploy \
            --template-file code-commit-mirror.yml \
            --parameter-overrides file://parameters.json \
            --stack-name $stackName \
            --capabilities CAPABILITY_NAMED_IAM \
            --no-fail-on-empty-changeset \
            --tags App=$APP_NAME \
            --region $region
        else
            aws cloudformation deploy \
            --template-file code-commit-mirror.yml \
            --stack-name $stackName \
            --capabilities CAPABILITY_NAMED_IAM \
            --no-fail-on-empty-changeset \
            --tags App=$APP_NAME \
            --region $region
        fi

        if [ $? -eq 0 ]; then
            local cmdResult="SUCCESS"
            local cfCodeCommitSecretArn
            get_mirror_secret_arn_from_cf_stack cfCodeCommitSecretArn "$stackName"
            if [[ -z "$cfCodeCommitSecretArn" ]]; then
                echo -e "${RED} ERROR: Failed to get ARN of secret that contains CodeCommit connection info.${NC}" >&2
                echo "Secret ARN should be in \"RepositoryCredsSecretArn\" output of the \"$stackName\" CloudFormation stack" >&2
            else
                register_push_mirror "$cfCodeCommitSecretArn"
            fi
        else
            local cmdResult="${RED}FAILURE${NC}"
        fi
    else
        local cmdResult="${RED}FAILURE${NC}"
    fi

    restore_template_files $cicdCodeCommitDir

    echo ""
    echo "Finished deploying CodeCommit push mirror CloudFormation stack"
    echo -e "Result: $cmdResult"
}

# Resolves environment variable placeholders in the CodeCommit push mirror
# CloudFormation template then executes "cloudformation delete-stack"
# param1: optional the AWS region to delete from. Defaults to $AWS_DEFAULT_REGION
destroy_code_commit_push_mirror_cf_stack () {
    local cicdCodeCommitDir=$projectCicdDir/code-commit-mirror

    [ ! -d "$cicdCodeCommitDir" ] && echo -e "${RED} ERROR: Directory $cicdCodeCommitDir DOES NOT EXIST${NC}" >&2 && exit 1

    set_aws_cli_profile
    validate_aws_cli_account

    cd $cicdCodeCommitDir

    local region=$1
    : ${region:=$AWS_DEFAULT_REGION} # set to default region if region was not passed as the first argument

    echo ""
    echo "Executing \"cloudformation delete-stack --stack-name $APP_NAME-codecommit\" for region: \"$region\""

    aws cloudformation delete-stack \
	--stack-name $APP_NAME-codecommit \
    --region $region

    aws cloudformation wait stack-delete-complete --stack-name $APP_NAME-codecommit
}

# Resolves environment variable placeholders in the CICD IAM Role
# CloudFormation template then executes "cloudformation deploy"
# param1: optional the AWS region to deploy to. Defaults to $AWS_DEFAULT_REGION
deploy_cicd_iam_role_cf_stack () {
    local cicdIamRoleDir=$projectCicdDir/iam-role

    [ ! -d "$cicdIamRoleDir" ] && echo -e "${RED} ERROR: Directory $cicdIamRoleDir DOES NOT EXIST${NC}" >&2 && exit 1

    echo ""
    echo "Deploying CICD IAM role CloudFormation stack..."

    set_aws_cli_profile
    validate_aws_cli_account

    resolve_template_files "backup" "$cicdIamRoleDir"

    if [ $? -eq 0 ]; then
        cd $cicdIamRoleDir

        local region=$1
        : ${region:=$AWS_DEFAULT_REGION} # set to default region if region was not passed as the first argument

        echo ""
        echo "Executing \"cloudformation deploy\" for region: \"$region\""

        if [[ -f "parameters.json" ]]; then
            aws cloudformation deploy \
            --template-file iam-role.yml \
            --parameter-overrides file://parameters.json \
            --stack-name $APP_NAME-$ENV_NAME-cicd-role \
            --capabilities CAPABILITY_NAMED_IAM \
            --no-fail-on-empty-changeset \
            --tags App=$APP_NAME Env=$ENV_NAME \
            --region $region
        else
            aws cloudformation deploy \
            --template-file iam-role.yml \
            --stack-name $APP_NAME-$ENV_NAME-cicd-role \
            --capabilities CAPABILITY_NAMED_IAM \
            --no-fail-on-empty-changeset \
            --tags App=$APP_NAME Env=$ENV_NAME \
            --region $region
        fi

        if [ $? -eq 0 ]; then
            local cmdResult="SUCCESS"
        else
            local cmdResult="${RED}FAILURE${NC}"
        fi
    else
        local cmdResult="${RED}FAILURE${NC}"
    fi

    restore_template_files $cicdIamRoleDir

    echo ""
    echo "Finished deploying CICD IAM role CloudFormation stack"
    echo -e "Result: $cmdResult"
}

# Resolves environment variable placeholders in the CICD IAM Role
# CloudFormation template then executes "cloudformation delete-stack"
# param1: optional the AWS region to delete from. Defaults to $AWS_DEFAULT_REGION
destroy_cicd_iam_role_cf_stack () {
    local cicdIamRoleDir=$projectCicdDir/iam-role

    [ ! -d "$cicdIamRoleDir" ] && echo -e "${RED} ERROR: Directory $cicdIamRoleDir DOES NOT EXIST${NC}" >&2 && exit 1

    set_aws_cli_profile
    validate_aws_cli_account

    cd $cicdIamRoleDir

    local region=$1
    : ${region:=$AWS_DEFAULT_REGION} # set to default region if region was not passed as the first argument

    echo ""
    echo "Executing \"cloudformation delete-stack --stack-name $APP_NAME-$ENV_NAME-cicd-role\" for region: \"$region\""

    aws cloudformation delete-stack \
	--stack-name $APP_NAME-$ENV_NAME-cicd-role \
    --region $region

    aws cloudformation wait stack-delete-complete --stack-name $APP_NAME-$ENV_NAME-cicd-role
}

# Executes cdk bootstrap for the current environment's AWS
# account and region.
# param1: optional. the region to deploy the CDK v2 bootstrap stack to
#         This overrides the current environment's region setting
deploy_cdk_bootstrap_cf_stack () {
    local cdkRegion=$1
    if [[ -z "$cdkRegion" ]]; then
        cdkRegion="$AWS_DEFAULT_REGION"
    fi

    echo ""
    echo "Deploying CDK v2 bootstrap CloudFormation stack..."

    set_aws_cli_profile
    validate_aws_cli_account

    resolve_template_files "backup" "$projectIacDir"

    if [ $? -eq 0 ]; then

        echo ""
        echo "Executing \"cdk bootstrap\""

        cdk bootstrap "aws://$AWS_ACCOUNT_ID/$cdkRegion"

        if [ $? -eq 0 ]; then
            local cmdResult="SUCCESS"
        else
            local cmdResult="${RED}FAILURE${NC}"
        fi

    else
        local cmdResult="${RED}FAILURE${NC}"
    fi

    restore_template_files $projectIacDir

    echo ""
    echo "Finished deploying CDK v2 bootstrap CloudFormation stack"
    echo -e "Result: $cmdResult"
}

# Runs cloudformation delete-stack --stack-name CDKToolkit
destroy_cdk_bootstrap_cf_stack () {

    set_aws_cli_profile
    validate_aws_cli_account

    echo ""
    echo "Executing \"cloudformation delete-stack --stack-name CDKToolkit\""

    aws cloudformation delete-stack --stack-name CDKToolkit

    aws cloudformation wait stack-delete-complete --stack-name CDKToolkit
}

# Resolves environment variable placeholders in the Terraform backend
# CloudFormation template then executes "cloudformation deploy"
# param1: optional the AWS region to deploy to. Defaults to $AWS_DEFAULT_REGION
# param2: optional the parameter values file name. Defaults to "parameters.json"
deploy_tf_backend_cf_stack () {
    local bootstrapDir=$projectIacDir/bootstrap

    [ ! -d "$bootstrapDir" ] && echo -e "${RED} ERROR: Directory $bootstrapDir DOES NOT EXIST${NC}" >&2 && exit 1

    echo ""
    echo -e "${CYAN}Deploying Terraform back end CloudFormation stack...${NC}"

    set_aws_cli_profile
    validate_aws_cli_account

    resolve_template_files "backup" "$bootstrapDir"

    if [ $? -eq 0 ]; then
        cd $bootstrapDir

        local region=$1
        : ${region:=$AWS_DEFAULT_REGION} # set to default region if region was not passed as the first argument

        local paramValuesFileName=$2
        : ${paramValuesFileName:="parameters.json"} # set to default if paramValuesFileName was not passed as the second argument

        echo ""
        echo "Executing \"cloudformation deploy\" for region: \"$region\""

        if [[ -f "$paramValuesFileName" ]]; then
            echo "Using parameter values from $paramValuesFileName"
            aws cloudformation deploy \
            --template-file tf-backend-cf-stack.yml \
            --parameter-overrides file://${paramValuesFileName} \
            --stack-name $TF_S3_BACKEND_NAME \
            --capabilities CAPABILITY_NAMED_IAM \
            --no-fail-on-empty-changeset \
            --tags App=$APP_NAME Env=$ENV_NAME \
            --region $region
        else
            aws cloudformation deploy \
            --template-file tf-backend-cf-stack.yml \
            --stack-name $TF_S3_BACKEND_NAME \
            --capabilities CAPABILITY_NAMED_IAM \
            --no-fail-on-empty-changeset \
            --tags App=$APP_NAME Env=$ENV_NAME \
            --region $region
        fi

        if [ $? -eq 0 ]; then
            local cmdResult="SUCCESS"
        else
            local cmdResult="${RED}FAILURE${NC}"
        fi
    else 
        local cmdResult="${RED}FAILURE${NC}"
    fi

    restore_template_files $bootstrapDir

    echo ""
    echo -e "${CYAN}Finished deploying Terraform back end CloudFormation stack${NC}"
    echo -e "Result: $cmdResult"
}

# Resolves environment variable placeholders in the Terraform backend
# CloudFormation template then executes "cloudformation delete-stack"
# param1: optional the AWS region to delete from. Defaults to $AWS_DEFAULT_REGION
destroy_tf_backend_cf_stack () {
    local bootstrapDir=$projectIacDir/bootstrap

    [ ! -d "$bootstrapDir" ] && echo -e "${RED} ERROR: Directory $bootstrapDir DOES NOT EXIST${NC}" >&2 && exit 1

    set_aws_cli_profile
    validate_aws_cli_account

    local region=$1
    : ${region:=$AWS_DEFAULT_REGION} # set to default region if region was not passed as the first argument

    cd $bootstrapDir

    echo ""
    echo "Executing \"cloudformation delete-stack --stack-name $TF_S3_BACKEND_NAME\" in region: \"$region\""

    aws cloudformation delete-stack \
	--stack-name $TF_S3_BACKEND_NAME \
    --region $region

    aws cloudformation wait stack-delete-complete --stack-name $TF_S3_BACKEND_NAME

    echo ""
    echo "Done deleting stack \"$TF_S3_BACKEND_NAME\" in region: \"$region\""
}

# Sets these variables based on this project's GitLab remote origin
# gitProjectGroup
# gitProjectName
# gitRepoDomain
set_gitlab_env_vars_from_remote_origin () {
    local gitRemote=$(git remote get-url --push origin)

    if [[ -z "$gitRemote" ]]; then
        return 1
    elif [[ $gitRemote = https* ]]; then
        local gitApiHost=$([[ $gitRemote =~ (https://[^/]*) ]] && echo ${BASH_REMATCH[1]})
        local projectName=${gitRemote#"$gitApiHost/"}
    else
        local projectName=$(echo $gitRemote | sed 's/.*://')
        local gitApiHost=${gitRemote%":$projectName"}
        gitApiHost=${gitApiHost:8}
    fi

    gitRepoDomain="$gitApiHost"

    local gitName="${projectName#*/}" # example value: myrepo.git
    gitProjectGroup=${projectName%/$gitName}; #Remove suffix
    gitProjectName=${gitName%.git}
}

# Sets these variables based on this project's CodeCommit remote origin
# gitProjectGroup
# gitProjectName
# gitRepoDomain
set_codecommit_env_vars_from_remote_origin () {
    if [[ -z "$gitRemote" ]]; then
        return 1
    fi

    if [[ $gitRemote = https* ]] || [[ $gitRemote == "ssh"* ]]; then
        gitRepoDomain="git-codecommit.$AWS_DEFAULT_REGION.amazonaws.com"
    else
        gitRepoDomain="codecommit::$AWS_DEFAULT_REGION:/"
    fi

    gitProjectName=${gitRemote##*/}
    gitProjectGroup="codecommit"
}

# Examines remote origin Git setting to set a Bash nameref variable with the Git repo provider
# This function should only be called when the current working directory is the project's
# home directory.
# param1: the Bash nameref variable to set with the Git repo provider
set_git_repo_type_from_remote_origin () {
    local -n repoProv=$1
    local gitRemote=$(git remote get-url --push origin 2> /dev/null)

    if [[ -z "$gitRemote" ]]; then
        :
    elif [[ $gitRemote == *"gitlab"* ]]; then
        repoProv="gitlab"
        set_gitlab_env_vars_from_remote_origin
    elif [[ $gitRemote == *"codecommit"* ]]; then
        repoProv="codecommit"
        set_codecommit_env_vars_from_remote_origin
    fi
}

# Examines remote origin Git setting to pull environment variable settings
set_git_env_vars_from_remote_origin () {

    if [[ ! -z "$CREATE_APP" ]]; then return 0; fi
    if [[ ! -d "$projectDir/.git" ]]; then return 0; fi

    local gitRemote=$(git remote get-url --push origin 2> /dev/null)

    if [[ -z "$gitRemote" ]]; then
        :
    elif [[ $gitRemote == *"gitlab"* ]]; then
        set_gitlab_env_vars_from_remote_origin
    elif [[ $gitRemote == *"codecommit"* ]]; then
        set_codecommit_env_vars_from_remote_origin
    else
        echo "WARNING: Could not detect how to parse git remote to set environment variables" >&2
    fi
}

# Determine the Gitlab API URL based on this project's remote origin
get_gitlab_api_url_from_remote_origin () {
    
    local gitRemote=$(git remote get-url --push origin)

    if [[ -z "$gitRemote" ]]; then
        return 1
    elif [[ $gitRemote = https* ]]; then
        local gitApiHost=$([[ $gitRemote =~ (https://[^/]*) ]] && echo ${BASH_REMATCH[1]})
        local projectName=${gitRemote#"$gitApiHost/"}
    else
        local projectName=$(echo $gitRemote | sed 's/.*://')
        local gitApiHost=${gitRemote%":$projectName"}
        gitApiHost=${gitApiHost:8}
        gitApiHost=https://${gitApiHost//:/$'/'}
    fi

    projectName=${projectName%".git"}
    projectName=$(echo "${projectName//\//$'%2f'}") # URL encode the / character
    echo "$gitApiHost/api/v4/projects/$projectName"
}

# Verifies that we know the information to connect to GitLab, either
# by pulling it from the current environment or by pulling it from
# the current projects "git remote" setting. Exits if we can't get
# the connection info through either means
validate_gitlab_env_vars () {
    if [[ -z "$gitRepoDomain" ]]; then

        set_gitlab_env_vars_from_remote_origin

        if [[ -z "$gitRepoDomain" ]]; then
            echo -e "${RED} ERROR: Failed to read GitLab repository details from local \".git\" configurations.${NC}" >&2
            echo "To fix this, either configure a remote Git origin for this project with the Git CLI" >&2
            echo "or set and export the following variables into the shell and retry:" >&2
            echo "    gitRepoDomain, gitProjectGroup, gitProjectName" >&2
            exit 1
        fi
    else 
        get_env_var_value "gitRepoDomain" 1> /dev/null || exit 1
        get_env_var_value "gitProjectGroup" 1> /dev/null || exit 1
        get_env_var_value "gitProjectName" 1> /dev/null || exit 1
    fi
}

# Retrieves GitLab environment names as a space-delimited string
# param1: the Bash nameref variable to set with the GitLab environment names
# param2: the GitLab access token to use in the request
get_gitlab_environment_names () {
    validate_gitlab_env_vars

    local -n envNameRef=$1
    local gitLabToken=$2
    ask_gitlab_token gitLabToken

    if [[ -z "$gitLabToken" ]];
    then
        echo -e "${RED} ERROR: you must supply a GitLab token to retrieve GitLab environment names${NC}" >&2
        return 1
    fi

    gitLabEnvironmentsApiUrl="https://$gitRepoDomain/api/v4/projects/$gitProjectGroup%2f$gitProjectName/environments"
    
    local response="$(curl \
        --request GET --header "PRIVATE-TOKEN: ${gitLabToken}" \
        -s -w "\n%{http_code}" \
        "${gitLabEnvironmentsApiUrl}")"

    local responseHttpCode=$(tail -n1 <<< "$response") # get the last line
    local jsonResponse=$(sed '$ d' <<< "$response")    # get all but the last line which contains the status code

    # Useful for debugging 
    # echo "HTTP Response Code: $responseHttpCode Response: $jsonResponse" >&2

    if [[ "$responseHttpCode" == "200" ]];
    then
        envNameRef=$(echo $jsonResponse | jq -r '[.[].name] | join(" ")')
    else
        echo -e "${RED} ERROR: HTTP response code from GitLab environment lookup was ${responseHttpCode}${NC}" >&2
    fi
}

# Retrieves AWS SSM Parameter Store environment names as a space-delimited string
get_ssm_environment_names () {
    get_env_var_value "AWS_DEFAULT_REGION" 1> /dev/null || exit 1
    get_env_var_value "APP_NAME" 1> /dev/null || exit 1

    local ssmEnvJson=$(aws ssm get-parameters-by-path \
    --region "$AWS_DEFAULT_REGION" \
    --max-items 300 \
    --recursive \
    --path "/$APP_NAME/remoteVars/" \
    --query "Parameters[].Name")

    ssmEnvJson=$(echo $ssmEnvJson \
    | jq -r "map( (ltrimstr(\"/$APP_NAME/remoteVars/\") | sub(\"/.*\"; \"\") ) ) | unique[]")

    echo $ssmEnvJson
}

# Detects which local environments exist by checking for environment-<env>.json files 
# and returns the results as a space-delimited string
get_local_environment_names () {
    local suffix=".json"
    local scriptDir=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )
    echo $(find $scriptDir -type f -name ".environment-*" | sed -e "s:^$scriptDir/.environment-::" -e "s/$suffix$//")
}

# Presents user with a choice of local environments and sets the 
# chosen environment to a Bash nameref variable
# param1: the name of the variable to set using the Bash nameref feature
# param2: the description of the choice action to show the user
choose_local_environment () {
    local -n envChoice=$1
    local selectDescription=$2
    local localEnvs=$(get_local_environment_names | sed -e 's/ /|/g')

    if [[ -z "$localEnvs" ]];
    then
        echo "You have no local environments." >&2
        exit 1
    fi

    echo "$selectDescription"
    envChoice=$(select_with_default "$localEnvs" "$localEnvs" "")
}

# Searches your local environment json files and gives you a choice of which to
# make your current local environment
switch_local_environment () {
    local switchTo
    choose_local_environment switchTo "Select a local environment to switch to:"
    local scriptDir=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )
    set_current_env $switchTo
    echo "Your local environment is now \"$switchTo\""
}

# Detects which remote environment variable store to query and returns the results
# as a space-delimited string
get_remote_environment_names () {
    get_env_var_value "REMOTE_ENV_VAR_LOC" 1> /dev/null || exit 1
    
    if [[ "$REMOTE_ENV_VAR_LOC" == "ssm" ]]; then
        echo $(get_ssm_environment_names)
    elif [[ "$REMOTE_ENV_VAR_LOC" == "gitlab" ]]; then
        local gitEnvNames
        get_gitlab_environment_names gitEnvNames ""
        echo $gitEnvNames
    elif [[ "$REMOTE_ENV_VAR_LOC" == "na" ]]; then
        echo -e "${RED} ERROR: cannot get remote environment names since REMOTE_ENV_VAR_LOC is \"$REMOTE_ENV_VAR_LOC\"${NC}" >&2
    else
        echo -e "${RED} ERROR: get_remote_environment_names does not currently support REMOTE_ENV_VAR_LOC = \"$REMOTE_ENV_VAR_LOC\"${NC}" >&2
    fi
}

# Pulls application environment variables from GitLab and
# saves them in the local .environment.json file.
# param1: optional - GitLab token
pull_env_vars_from_gitlab_to_local_json () {
    validate_gitlab_env_vars
    get_env_var_value "ENV_NAME" 1> /dev/null || exit 1

    local gitLabToken=$1
    ask_gitlab_token gitLabToken

    if [[ -z "$gitLabToken" ]]; then
        echo -e "${RED} ERROR: you must supply a GitLab token to retrieve GitLab environment variables${NC}" >&2
        exit 1
    fi

    gitLabVarsApiUrl="https://$gitRepoDomain/api/v4/projects/$gitProjectGroup%2f$gitProjectName/variables"

    # Make a request that will return response headers, response code, and response body
    local perPage=100
    local response="$(curl --globoff \
        --request GET --header "PRIVATE-TOKEN: ${gitLabToken}" \
        -s -w "\n%{http_code}" -i \
        "${gitLabVarsApiUrl}?per_page=${perPage}&page=1")"

    # Useful for debugging 
    # echo "" >&2
    # echo "$response" >&2
    # echo "" >&2

    # get "x-total-pages" response header value
    local totalPages=$(echo "$response" | grep -m1 ^x-total-pages | sed 's/^x-total-pages: //')
    totalPages=${totalPages%%[[:space:]]}

    # Useful for debugging 
    # echo "" >&2
    # echo "totalPages is \"$totalPages\"" >&2
    # echo "" >&2

    # Strip all response headers from the response
    # The response body comes after a blank line
    response=$(echo "$response" | sed -e '1,/^\r$/d')

    local responseHttpCode=$(tail -n1 <<< "$response") # get the last line
    local jsonResponse=$(sed '$ d' <<< "$response")    # get all but the last line which contains the status code

    # Useful for debugging 
    # echo "HTTP Response Code: $responseHttpCode Response: $jsonResponse" >&2

    if [[ "$responseHttpCode" == "200" ]]; then

        # GitLab paginates responses so we may need multiple requests
        local requestCount
        for (( requestCount=1; requestCount < totalPages; requestCount++ )); do

            # Useful for debugging
            # echo "MAKING ANOTHER REQUEST"

            local pageUrl=$(echo "${gitLabVarsApiUrl}?per_page=${perPage}&page=$((requestCount+1))")
            
            # Useful for debugging
            # echo "$pageUrl"

            # Won't return response headers
            local simpleResponse="$(curl --globoff \
            --request GET --header "PRIVATE-TOKEN: ${gitLabToken}" \
            -s -w "\n%{http_code}" \
            "$pageUrl")"

            local simpleResponseHttpCode=$(tail -n1 <<< "$simpleResponse") # get the last line
            local simpleJsonResponse=$(sed '$ d' <<< "$simpleResponse")    # get all but the last line which contains the status code

            # Useful for debugging 
            # echo "Subsequent request response code: $simpleResponseHttpCode"
            # echo "$simpleJsonResponse"

            # Append the existing response array with the new response array
            if [[ "$simpleResponseHttpCode" == "200" ]]; then
                jsonResponse=$(echo -e "${jsonResponse}\n${simpleJsonResponse}" | jq -s 'add')
            else
                echo -e "${RED} ERROR: HTTP response code from GitLab environment variable lookup was ${simpleResponseHttpCode}${NC}" >&2
                exit 1
            fi
            
        done

        # Filter objects in the response that do not match the current environment
        # and write the variable values out to a JSON file
        local environmentJsonFile=$(get_env_var_file_name)
        echo $jsonResponse | jq --arg ENV_NAME "$ENV_NAME" '[.[] | select((.environment_scope==$ENV_NAME) or (.key|startswith("SONAR_")))]' | jq '. |= map( { (.key) : .value } ) | add' > $environmentJsonFile
    else
        echo -e "${RED} ERROR: HTTP response code from GitLab environment variable lookup was ${responseHttpCode}${NC}" >&2
        exit 1
    fi
}

# Pulls application environment variables from the AWS SSM Parameter Store and
# saves them in the local .environment.json file.
pull_env_vars_from_ssm_to_local_json () {

    local ssmEnvJson=$(aws ssm get-parameters-by-path \
    --region "$AWS_DEFAULT_REGION" \
    --max-items 200 \
    --path "/$APP_NAME/remoteVars/$ENV_NAME/" \
    --with-decryption \
    --query "Parameters[].{key:Name,value:Value}")

    local environmentJsonFile=$(get_env_var_file_name)
    echo $ssmEnvJson | jq "map( {(.key|ltrimstr(\"/$APP_NAME/remoteVars/$ENV_NAME/\")) : .value } ) | add" > $environmentJsonFile
}

# Sets application environment variables into AWS SSM Parameter Store
set_ssm_remote_vars_for_env () {
    echo ""
    echo "Posting environment variables to AWS SSM Parameter Store"
    echo environment_scope is $ENV_NAME

    local envVarNames
    get_env_var_names envVarNames || exit 1

    for i in ${!envVarNames[@]}; do
        local varName=${envVarNames[$i]}

        # ignore dynamic variables since they are not stored remotely
        if [[ ! -z "${LOOKUPS[$varName]}" ]]; then 
            continue
        fi
        
        # check that the env var value can be retrieved or exit if not
        get_env_var_value $varName 1> /dev/null || exit 1
        local envVarValue=$(get_env_var_value $varName)
        local paramName="/$APP_NAME/remoteVars/$ENV_NAME/$varName"
        
        echo "Posting $varName with key $paramName to region $AWS_DEFAULT_REGION"
        aws ssm put-parameter \
        --region "$AWS_DEFAULT_REGION" \
        --name "$paramName" \
        --type "SecureString" \
        --value "$envVarValue" \
        --overwrite 1> /dev/null || echo -e "${RED} ERROR: could not create or update $varName with environment_scope ${ENV_NAME}${NC}" >&2

        # note - you can't use overwrite and tags together so tagging is done separately
        aws ssm add-tags-to-resource \
        --region "$AWS_DEFAULT_REGION" \
        --resource-type "Parameter" \
        --resource-id "$paramName" \
        --tags "[{\"Key\":\"App\",\"Value\":\"$APP_NAME\"},{\"Key\":\"Env\", \"Value\":\"$ENV_NAME\"}]" \
        1> /dev/null || echo -e "${RED} ERROR: could not tag ${paramName}${NC}" >&2

    done

    echo ""
    echo "Done posting environment variables to AWS SSM Parameter Store"
    echo ""
}

# Deletes application environment variables from AWS SSM Parameter Store
delete_ssm_remote_vars_for_env () {
    # check that the env var value can be retrieved or exit if not
    get_env_var_value "APP_NAME" 1> /dev/null || exit 1
    get_env_var_value "ENV_NAME" 1> /dev/null || exit 1

    local paramPath="/$APP_NAME/remoteVars/$ENV_NAME/"
    local deleteSure
    yes_or_no deleteSure "Are you sure you want to delete SSM variables with path ${paramPath} ?" "n"

    if [[ "$deleteSure" == "y" ]]; then
        echo "Deleting SSM variables with path ${paramPath} ..."
        aws ssm get-parameters-by-path --path $paramPath --recursive | \
        jq '.Parameters[].Name' | \
        xargs -L1 -I'{}' aws ssm delete-parameter --name {}
        echo "Deletion complete."
    fi
}

# Retrieves the push mirror connection info secret ARN from a CICD cdk/cloudformation stack.
# param1: the name of the variable to set using the Bash nameref feature
# param2: cdk/cloudformation stack name that contains secret with CodeCommit connection info
get_mirror_secret_arn_from_cf_stack () {
    local -n secretArn=$1
    local stackName=$2

    # Get secret that contains info for connecting to CodeCommit
    secretArn=$(aws cloudformation describe-stacks \
    --stack-name $stackName \
    --query 'Stacks[0].Outputs[?contains(OutputKey, `RepositoryCredsSecretArn`) == `true`].OutputValue' \
    --output text)
}

# Adds a push mirror setting for upstream repo to push to CodeCommit.
# param1: ARN of secret that contains info for connecting to CodeCommit
register_push_mirror () {
    local secretArn=$1

    if [[ -z "$gitRepoDomain" ]]; then
        set_git_env_vars_from_remote_origin
    fi

    if [[ "$gitRepoDomain" =~ "gitlab" ]]; then
        echo ""
        echo -e "${CYAN}Attempting to register CodeCommit push mirror...${NC}"
        
        local gitLabToken
        ask_gitlab_token gitLabToken

        if [[ -z "$gitLabToken" ]]; then
            echo -e "${CYAN}GitLab access token not found. Skipping push mirror registration.${NC}"
            return 0
        fi

        # Parse info out of secret value
        local secretVal=$(aws secretsmanager get-secret-value --secret-id $secretArn --output json | jq --raw-output '.SecretString')
        local apiRepoUrl=$(echo "$secretVal" | jq -r '.apiRepoUrl')
        # URL encoding for password:
        apiRepoUrl=${apiRepoUrl//+/%2B} # replace any "+" since its not valid in a URL
        apiRepoUrl=${apiRepoUrl//=/%3D} # replace any "=" since its not valid in a URL
        local repoName="${apiRepoUrl##*\/}" # example result: "myrepo.git"

        # List current push mirrors for the upstream repo
        local gitLabMirrorsApiUrl="https://$gitRepoDomain/api/v4/projects/$gitProjectGroup%2f$gitProjectName/remote_mirrors"
        local listResponse=$(curl -s -w "\n%{http_code}" --globoff --header "PRIVATE-TOKEN: $gitLabToken" "${gitLabMirrorsApiUrl}")
        
        local listResponseHttpCode=$(tail -n1 <<< "$listResponse") # get the last line
        local listJsonResponse=$(sed '$ d' <<< "$listResponse")    # get all but the last line which contains the status code

        if [[ "$listResponseHttpCode" == 200 ]]; then
            local mirrorUrls=$(echo $listJsonResponse | jq -r '[.[].url] | join(" ")')
            if [[ "$mirrorUrls" == *"$repoName"* ]]; then
                echo -e "${CYAN}$repoName has already been registered as a push mirror for the $gitProjectGroup/$gitProjectName repo.${NC}"
                return 0
            fi
        else
            echo -e "${RED} ERROR: Failed to retrieve existing upstream repo mirrors${NC}" >&2
            echo "  Check that the GitLab access token is valid and has the correct permissions." >&2
            echo "  HTTP Code: $listResponseHttpCode Response: $listJsonResponse" >&2
            echo -e "${RED}Failed to register CodeCommit push mirror.${NC}"
            return 0
        fi

        # Register push mirror repo
        local response=$(curl -s -w "\n%{http_code}" --globoff \
        --request POST --header "PRIVATE-TOKEN: ${gitLabToken}" \
        "${gitLabMirrorsApiUrl}" \
        --data "url=${apiRepoUrl}&enabled=true&keep_divergent_refs=false")

        local responseHttpCode=$(tail -n1 <<< "$response") # get the last line
        local jsonResponse=$(sed '$ d' <<< "$response")    # get all but the last line which contains the status code

        if [[ "$responseHttpCode" != 201 ]]; then
            echo -e "${RED} ERROR: failed to register CodeCommit push mirror \"$repoName\"${NC}" >&2
            echo "  HTTP Code: $responseHttpCode Response: $jsonResponse" >&2
        else
            echo -e "${CYAN}Successfully registered CodeCommit push mirror \"$repoName\"${NC}"
            echo ""
        fi
        
    else
        echo -e "${YELLOW}WARN: automatic CodeCommit push mirror registration currently only supports GitLab repositories.${NC}"
        echo ""
    fi

}

# Sets environment variables for CICD pipelines on GitLab
# Requires Maintainer privileges on the GitLab repo and an access token
set_gitlab_cicd_vars_for_env () {
    echo "Saving environment variable settings using GitLab"

    local gitLabToken
    ask_gitlab_token gitLabToken
    if [[ -z "$gitLabToken" ]]; then
        echo "Skipping setting GitLab environment variables for the \"$ENV_NAME\" environment."
        exit 0
    fi

    if [[ -z "$gitRepoDomain" ]]; then
        set_git_env_vars_from_remote_origin
    fi

    local gitLabProjectsApiUrl="https://$gitRepoDomain/api/v4/projects/$gitProjectGroup%2f$gitProjectName"

    confirm_gitlab_repo_exists || return 1

    # Check for gitlab environment, and create it if it is not found
    local envNames
    get_gitlab_environment_names envNames $gitLabToken
    local envExists="n"
    if [[ " ${envNames} " =~ " ${ENV_NAME} " ]]; then
        envExists="y"
    fi

    if [[ "$envExists" != "y" ]]; then
        create_gitlab_cicd_environment $gitLabToken || exit 1
    fi

    gitLabVariablesApiUrl="${gitLabProjectsApiUrl}/variables"
    echo ""
    echo "Posting environment variables to $gitLabVariablesApiUrl"
    echo environment_scope is $ENV_NAME

    local envVarNames
    get_env_var_names envVarNames || exit 1

    for i in ${!envVarNames[@]}; do
        local varName=${envVarNames[$i]}

        # ignore dynamic variables since they are not stored remotely
        if [[ ! -z "${LOOKUPS[$varName]}" ]]; then 
            continue
        fi
        
        # check that the env var value can be retrieved or exit if not
        get_env_var_value $varName 1> /dev/null || exit 1
        local envVarValue=$(get_env_var_value $varName)
        
        local masked
        # Only certain values can be masked
        # See https://gitlab.com/help/ci/variables/index#mask-a-cicd-variable
        [[ "$envVarValue" =~ ^[a-zA-Z0-9+\/@:.~]{8,}$ ]] && masked="true" || masked="false"

        if [[ "$varName" == "SONAR_TOKEN" ]]; then
            masked="true"
        fi

        local envScope
        if [[ "$varName" == SONAR_* ]]; then
            envScope="*"
        else
            envScope="$ENV_NAME"
        fi

        echo ""
        echo "Creating $varName with scope=$envScope, masked=$masked"
        local response=$(curl -s -w "\n%{http_code}" --globoff \
        --request POST --header "PRIVATE-TOKEN: ${gitLabToken}" \
        "${gitLabVariablesApiUrl}?filter[environment_scope]=$ENV_NAME" \
        --form "key=$varName" \
        --form "value=$envVarValue" \
        --form "protected=false" \
        --form "masked=$masked" \
        --form "environment_scope=$envScope")

        local responseHttpCode=$(tail -n1 <<< "$response") # get the last line
        local jsonResponse=$(sed '$ d' <<< "$response")    # get all but the last line which contains the status code

        if [[ "$responseHttpCode" != 201 ]]; then
            echo "Could not create $varName. $jsonResponse"
            echo "Trying to update $varName instead..."

            local updateResponse=$(curl -s -w "\n%{http_code}" --globoff \
            --request PUT --header "PRIVATE-TOKEN: ${gitLabToken}" \
            "${gitLabVariablesApiUrl}/$varName?filter[environment_scope]=$envScope" \
            --form "value=$envVarValue" \
            --form "protected=false" \
            --form "masked=$masked" \
            --form "environment_scope=$envScope")

            local updateResponseHttpCode=$(tail -n1 <<< "$updateResponse") # get the last line
            local updateJsonResponse=$(sed '$ d' <<< "$updateResponse")    # get all but the last line which contains the status code

            if [[ "$updateResponseHttpCode" != 200 ]];
            then
                echo -e "${RED} ERROR: could not create or update $varName with environment_scope ${envScope}${NC}" >&2
                echo "  HTTP Code: $updateResponseHttpCode Response: $updateJsonResponse" >&2
            else
                echo "Updated $varName"
            fi

        fi

    done

    echo ""
    echo "Done posting environment variables to $gitLabVariablesApiUrl"
    echo ""

}

# Deletes the current environment's variables from GitLab CICD
# Does NOT delete the GitLab environment itself
# param1: optional - the GitLab token
delete_gitlab_cicd_vars_for_env () {
    # ensure that environment variables needed by this function are set
    get_env_var_value "ENV_NAME" 1> /dev/null || exit 1
    validate_gitlab_env_vars
    
    local deleteSure
    echo ""
    yes_or_no deleteSure "Are you sure you want to delete GitLab CICD variables for environment \"${ENV_NAME}\"?" "n"

    if [[ "$deleteSure" != "y" ]]; then
        return 0
    fi

    local gitLabToken=$1
    ask_gitlab_token gitLabToken

    if [[ -z "$gitLabToken" ]]; then
        echo "Skipping deleting GitLab CICD environment variables"
        exit 0
    fi

    if [[ -z "$gitRepoDomain" ]]; then
        set_git_env_vars_from_remote_origin
    fi

    local gitLabProjectsApiUrl="https://$gitRepoDomain/api/v4/projects/$gitProjectGroup%2f$gitProjectName"

    confirm_gitlab_repo_exists || return 1

    gitLabVariablesApiUrl="${gitLabProjectsApiUrl}/variables"
    echo ""
    echo "Deleting GitLab \"$ENV_NAME\" environment variables from $gitLabVariablesApiUrl"

    local envVarNames
    get_env_var_names envVarNames || exit 1

    for i in ${!envVarNames[@]}; do
        local varName=${envVarNames[$i]}

        # ignore dynamic variables since they are not stored remotely
        if [[ ! -z "${LOOKUPS[$varName]}" ]]; then 
            continue
        fi
        
        # check that the env var value can be retrieved or exit if not
        get_env_var_value $varName 1> /dev/null || exit 1
        local envVarValue=$(get_env_var_value $varName)
        
        echo ""
        echo "Deleting $varName ..."
        local response=$(curl -s -w "\n%{http_code}" --globoff \
        --request DELETE --header "PRIVATE-TOKEN: ${gitLabToken}" \
        "${gitLabVariablesApiUrl}/$varName?filter[environment_scope]=$ENV_NAME")

        local responseHttpCode=$(tail -n1 <<< "$response") # get the last line
        local jsonResponse=$(sed '$ d' <<< "$response")    # get all but the last line which contains the status code

        if [[ "$responseHttpCode" == 204 ]];
        then
            echo "Deleted"
        elif [[ "$responseHttpCode" == 404 ]];
        then
            echo "\"$varName\" was not configured as a GitLab CICD \"$ENV_NAME\" environment variable"
        else
            echo "Deletion not successful. HTTP Response Code: $responseHttpCode Response: $jsonResponse"
        fi

    done

    echo ""
    echo "Done deleting \"$ENV_NAME\" environment variables from GitLab CICD."
}

# Deletes the current environment from GitLab
# Does NOT delete GitLab CICD environment variables, just deletes the environment
# param1: optional - the GitLab token
delete_gitlab_cicd_environment () {
    # ensure that environment variables needed by this function are set
    get_env_var_value "ENV_NAME" 1> /dev/null || exit 1
    validate_gitlab_env_vars
    
    local deleteSure
    echo ""
    yes_or_no deleteSure "Are you sure you want to delete GitLab CICD \"${ENV_NAME}\" environment?" "n"
    echo ""

    if [[ "$deleteSure" != "y" ]]; then
        return 0
    fi

    local gitLabToken=$1
    ask_gitlab_token gitLabToken
    
    if [[ -z "$gitLabToken" ]]; then
        echo "Skipping deleting GitLab CICD environment"
        exit 0
    fi

    if [[ -z "$gitRepoDomain" ]]; then
        set_git_env_vars_from_remote_origin
    fi

    local gitLabProjectsApiUrl="https://$gitRepoDomain/api/v4/projects/$gitProjectGroup%2f$gitProjectName"

    confirm_gitlab_repo_exists || return 1

    local gitLabEnvironmentsApiUrl="https://$gitRepoDomain/api/v4/projects/$gitProjectGroup%2f$gitProjectName/environments"
    
    local response="$(curl \
        --request GET --header "PRIVATE-TOKEN: ${gitLabToken}" \
        -s -w "\n%{http_code}" \
        "${gitLabEnvironmentsApiUrl}")"

    local responseHttpCode=$(tail -n1 <<< "$response") # get the last line
    local jsonResponse=$(sed '$ d' <<< "$response")    # get all but the last line which contains the status code

    if [[ "$responseHttpCode" == "200" ]]; then
        local envId=$(echo $jsonResponse | jq -r --arg ENV_NAME "$ENV_NAME" '.[] | select(.name==$ENV_NAME).id')
    else
        echo -e "${RED} ERROR: HTTP response code from GitLab environment lookup was ${responseHttpCode}${NC}" >&2
    fi

    if [[ -z "$envId" ]]; then
        echo "INFO: No GitLab environment with name \"$ENV_NAME\" was found."
        return 0
    fi

    local gitLabEnvUrl="${gitLabProjectsApiUrl}/environments/${envId}/stop"
    echo "Stopping GitLab \"${ENV_NAME}\" environment at $gitLabEnvUrl"
    
    local response="$(curl \
        --request POST --header "PRIVATE-TOKEN: ${gitLabToken}" \
        -s -w "\n%{http_code}" \
        "${gitLabEnvUrl}")"

    responseHttpCode=$(tail -n1 <<< "$response") # get the last line
    jsonResponse=$(sed '$ d' <<< "$response")    # get all but the last line which contains the status code

    if [[ "$responseHttpCode" != 200 ]]; then
        echo -e "${RED} ERROR: could not stop GitLab environment \"$ENV_NAME\".${NC}" >&2
        echo "HTTP Response Code: $responseHttpCode - Response - $jsonResponse" >&2
        exit 1
    else
        echo "GitLab environment \"$ENV_NAME\" was successfully stopped"
    fi

    gitLabEnvUrl="${gitLabProjectsApiUrl}/environments/${envId}"
    echo ""
    echo "Deleting GitLab \"${ENV_NAME}\" environment at $gitLabEnvUrl"
    
    local response="$(curl \
        --request DELETE --header "PRIVATE-TOKEN: ${gitLabToken}" \
        -s -w "\n%{http_code}" \
        "${gitLabEnvUrl}")"

    local responseHttpCode=$(tail -n1 <<< "$response") # get the last line
    local jsonResponse=$(sed '$ d' <<< "$response")    # get all but the last line which contains the status code

    if [[ "$responseHttpCode" != 204 ]]; then
        echo -e "${RED} ERROR: could not delete GitLab environment \"$ENV_NAME\".${NC}" >&2
        echo "HTTP Response Code: $responseHttpCode - Response - $jsonResponse" >&2
    else
        echo "GitLab environment \"$ENV_NAME\" was successfully deleted"
    fi
}

# Creates an environment in the GitLab repository
# Does NOT create GitLab CICD environment variables, just creates the environment
create_gitlab_cicd_environment () {
    # ensure that environment variables needed by this function are set
    get_env_var_value "ENV_NAME" 1> /dev/null || exit 1
    validate_gitlab_env_vars
    
    local gitLabToken=$1
    ask_gitlab_token gitLabToken
    
    if [[ -z "$gitLabToken" ]]; then
        echo "Skipping creating GitLab CICD environment"
        exit 0
    fi

    echo "Creating \"$ENV_NAME\" environment on GitLab..."

    if [[ -z "$gitRepoDomain" ]]; then
        set_git_env_vars_from_remote_origin
    fi

    local gitLabProjectsApiUrl="https://$gitRepoDomain/api/v4/projects/$gitProjectGroup%2f$gitProjectName"

    confirm_gitlab_repo_exists || return 1

    local gitLabEnvironmentsApiUrl="https://$gitRepoDomain/api/v4/projects/$gitProjectGroup%2f$gitProjectName/environments"
    
    local response="$(curl \
        --request POST --header "PRIVATE-TOKEN: ${gitLabToken}" \
        -s -w "\n%{http_code}" \
        --data "name=$ENV_NAME" \
        "${gitLabEnvironmentsApiUrl}")"

    local responseHttpCode=$(tail -n1 <<< "$response") # get the last line
    local jsonResponse=$(sed '$ d' <<< "$response")    # get all but the last line which contains the status code

    if [[ "$responseHttpCode" != "201" ]]; then
        echo -e "${RED} ERROR: HTTP response code from GitLab environment creation was ${responseHttpCode}${NC}" >&2
        exit 1
    else
        echo "Successfully created \"$ENV_NAME\" environment on GitLab!"
    fi
}

# Sends current local environment variable settings to remote storage
# so that they can be referenced by the CICD pipeline or other members
# of the development team
push_env_vars () {
    # check that the env var value can be retrieved or exit if not
    get_env_var_value REMOTE_ENV_VAR_LOC 1> /dev/null || exit 1
    local envVarLoc=$(get_env_var_value REMOTE_ENV_VAR_LOC)

    if [[ "$envVarLoc" == "gitlab" ]]; then        
        set_gitlab_cicd_vars_for_env
    elif [[ "$envVarLoc" == "ssm" ]]; then
        set_ssm_remote_vars_for_env
    elif [[ "$envVarLoc" == "NA" ]] || [[ "$envVarLoc" == "na" ]]; then
        echo "Skipping exporting environment variables since REMOTE_ENV_VAR_LOC=$envVarLoc"
    else
        echo -e "${RED} ERROR: no implementation found to export environment variables to location: ${envVarLoc}${NC}" >&2
        exit 1
    fi
}

# Creates a project token in SonarQube for the application.
# param1: optional - existing sonarqube user token value
create_sonarqube_project_token () {
    echo ""
    echo -e "${CYAN}Creating SonarQube project token for \"$SONAR_PROJECT_KEY\"...${NC}"

    local sonarUserToken=$1
    ask_sonarqube_user_token sonarUserToken
    if [[ -z "$sonarUserToken" ]]; then
        echo ""
        echo -e "${CYAN}Skipping creating SonarQube project token.${NC}"
        SONAR_TOKEN="setme"
        exit 0
    fi

    local tokenResponse=$(curl -s -w "\n%{http_code}" --globoff \
    --request POST --header "Content-Type: application/x-www-form-urlencoded" \
    -u $sonarUserToken: \
    "$SONAR_HOST_URL/api/user_tokens/generate" \
    --data "projectKey=$SONAR_PROJECT_KEY&name=project_$APP_NAME&type=PROJECT_ANALYSIS_TOKEN")

    local tokenResponseHttpCode=$(tail -n1 <<< "$tokenResponse") # get the last line
    local tokenJsonResponse=$(sed '$ d' <<< "$tokenResponse")    # get all but the last line which contains the status code

    if [[ "$tokenResponseHttpCode" == "200" ]]; then
        echo "Successfully created SonarQube project token"
        SONAR_TOKEN=$(echo $tokenJsonResponse | jq -r '.token')
    else
        echo -e "${RED} ERROR: Failed to create SonarQube project token. Response status code: $tokenResponseHttpCode${NC}" >&2
        SONAR_TOKEN="setme"
    fi

    echo "$tokenJsonResponse"
    echo ""

    echo -e "${CYAN}Finished creating SonarQube project token for \"$SONAR_PROJECT_KEY\".${NC}"
    echo ""
}

# Updates the project's main branch setting on SonarQube.
# param1: optional - existing sonarqube user token value
update_sonarqube_project_main_branch () {

    echo ""
    length_range sonarQubeMainBranch "Which Git branch should SonarQube use as your main branch:" \
    "main" "1" "60"

    if [[ "$sonarQubeMainBranch" == "master" ]]; then
        return 0 # this is the default value
    fi

    echo ""
    echo -e "${CYAN}Updating SonarQube \"$SONAR_PROJECT_KEY\" project main branch setting to \"$sonarQubeMainBranch\"...${NC}"

    local sonarUserToken=$1
    ask_sonarqube_user_token sonarUserToken
    if [[ -z "$sonarUserToken" ]]; then
        echo ""
        echo -e "${CYAN}Skipping creating SonarQube project token.${NC}"
        SONAR_TOKEN="setme"
        exit 0
    fi

    local branchResponse=$(curl -s -w "\n%{http_code}" --globoff \
    --request POST --header "Content-Type: application/x-www-form-urlencoded" \
    -u $sonarUserToken: \
    "$SONAR_HOST_URL/api/project_branches/rename" \
    --data "project=$SONAR_PROJECT_KEY&name=$sonarQubeMainBranch")

    local branchResponseHttpCode=$(tail -n1 <<< "$branchResponse") # get the last line
    local branchJsonResponse=$(sed '$ d' <<< "$branchResponse")    # get all but the last line which contains the status code

    if [[ "$branchResponseHttpCode" == "204" ]]; then
        echo "Successfully updated SonarQube \"$SONAR_PROJECT_KEY\" project main branch setting"
    else
        echo -e "${RED} ERROR: Failed to update SonarQube \"$SONAR_PROJECT_KEY\" project main branch setting. Response status code: $branchResponseHttpCode${NC}" >&2
    fi

    echo "$branchJsonResponse"
    echo ""

    echo -e "${CYAN}Finished updating SonarQube \"$SONAR_PROJECT_KEY\" project main branch setting to \"$sonarQubeMainBranch\"...${NC}"
    echo ""
}

# Creates a project in SonarQube for the application.
create_sonarqube_project () {

    echo ""
    echo -e "${CYAN}Creating SonarQube Project...${NC}"

    local sonarUserToken
    ask_sonarqube_user_token sonarUserToken
    if [[ -z "$sonarUserToken" ]]; then
        echo ""
        echo -e "${CYAN}Skipping creating SonarQube project.${NC}"
        SONAR_PROJECT_KEY="setme"
        SONAR_TOKEN="setme"
        exit 0
    fi

    local projectResponse=$(curl -s -w "\n%{http_code}" --globoff \
    --request POST --header "Content-Type: application/x-www-form-urlencoded" \
    -u $sonarUserToken: \
    "$SONAR_HOST_URL/api/projects/create" \
    --data "project=$APP_NAME&name=$APP_NAME&visibility=private")

    local projectResponseHttpCode=$(tail -n1 <<< "$projectResponse") # get the last line
    local projectJsonResponse=$(sed '$ d' <<< "$projectResponse")    # get all but the last line which contains the status code

    # Example success response
    # {"project":{"key":"myapp","name":"myapp","qualifier":"TRK","visibility":"private"}}

    if [[ "$projectResponseHttpCode" == "200" ]]; then
        SONAR_PROJECT_KEY="$(echo $projectJsonResponse | jq -r '.project.key')"

        echo "Successfully created SonarQube project"
        echo "$projectJsonResponse"
        
        update_sonarqube_project_main_branch "$sonarUserToken"
        create_sonarqube_project_token "$sonarUserToken"

    else
        SONAR_PROJECT_KEY="$APP_NAME"
        SONAR_TOKEN="setme"

        # Example "project already exists" response (HTTP status 400)
        # {"errors":[{"msg":"Could not create Project, key already exists: myapp"}]}

        echo -e "${RED} ERROR: Failed to create SonarQube project. Response status code: $projectResponseHttpCode${NC}" >&2
        echo "$projectJsonResponse"
        echo ""
        
        if [[ "$projectResponseHttpCode" == "400" ]] && [[ $projectJsonResponse == *"key already exists"* ]]; then
            echo "You will need to ask the person that created the SonarQube project"
            echo "for the project token and use the value to set the SONAR_TOKEN environment variable"
            echo ""
        fi
    fi

    echo ""
    echo -e "${CYAN}Finished creating SonarQube Project${NC}"
    echo ""
}

# Prints a table of CloudTrail logs for IAM permission denied events
# over a date range. Useful for debugging IAM role permissions
# param1: optional - the start date to search logs from. Defaults to today.
#         example value: 2023-01-15
# param2: optional - the end date to search logs to. Defaults to tomorrow.
#         example value: 2023-01-16
print_auth_errors () {

    set_aws_cli_profile
    validate_aws_cli_account

    local startDate=$1
    if [[ -z "$startDate" ]]; then
        # default to today
        startDate=$(date +%Y-%m-%d)
    fi

    local endDate=$2
    if [[ -z "$endDate" ]]; then 
        # default to tomorrow
        endDate=$(date -v+1d +%Y-%m-%d)
    fi

    echo ""
    echo "Looking up IAM permission-denied logs in CloudTrail between ${startDate} and ${endDate}"
    echo "This may take 1 to 5 minutes..."
    echo ""

    ( echo "Time,Identity ARN,Event ID,Service,Action,Error,Message";
    aws cloudtrail lookup-events --start-time "${startDate}T00:00:00Z" --end-time "${endDate}T00:00:00Z" --query "Events[*].CloudTrailEvent" --output text \
        | jq -r ". | select(.eventType == \"AwsApiCall\" and .errorCode != null
        and (.errorCode | ascii_downcase | (contains(\"accessdenied\") or contains(\"unauthorized\"))))
        | [.eventTime, .userIdentity.arn, .eventID, .eventSource, .eventName, .errorCode, .errorMessage] | @csv"
    ) | column -t -s'",'
}

# This array is globally scoped and provides the ability to dynamically
# add required application environment variables, such as based on 
# user choices from the Create App Wizard.
OPT_IN_ENV_VAR_KEYS=()

# Global variable holding the suffix to append to a filename
# when making a backup
BACKUP_SUFFIX=".bak"

set_project_locations
set_colors

if [[ -f "$projectEnvDir/dynamic-lookups.sh" ]]; then
    source $projectEnvDir/dynamic-lookups.sh 1> /dev/null
    LOOKUP_VALS_JSON="{}"

    if [[ "${#LOOKUPS[@]}" == "0" ]]; then
        DYNAMIC_RESOLUTION="na"
    fi
else
    declare -A LOOKUPS=()
    DYNAMIC_RESOLUTION="na"
fi

if [[ -z "$1" ]]; then
    # print out the function names defined in this script
    echo USAGE: Pass one of these function names and its input parameter
    echo values as arguments to this script to execute it:
    declare -F | sed "s/declare -f//"
elif [[ "$1" == "get_env_var_names" ]]; then
    ROOT_CONTEXT="get_env_var_names"
    echo get_env_var_names
    declare myEnvVarKeysList
    get_env_var_names myEnvVarKeysList || exit 1
    for i in ${!myEnvVarKeysList[@]}; do
        echo ${myEnvVarKeysList[$i]}
    done
elif [[ "$1" == "source" ]]; then
    :
else
    ROOT_CONTEXT="$@"
    # This allows you to call a function within this script from a
    # command prompt by passing in the name of the function and any
    # arguments to the function.
    "$@"; exit
fi
